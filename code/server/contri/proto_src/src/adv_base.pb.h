// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: adv_base.proto

#ifndef PROTOBUF_adv_5fbase_2eproto__INCLUDED
#define PROTOBUF_adv_5fbase_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace adv {
namespace msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_adv_5fbase_2eproto();
void protobuf_AssignDesc_adv_5fbase_2eproto();
void protobuf_ShutdownFile_adv_5fbase_2eproto();

class RetBase;
class TaskInfo;
class PField;
class PRow;
class PDataCell;

// ===================================================================

class RetBase : public ::google::protobuf::Message {
 public:
  RetBase();
  virtual ~RetBase();
  
  RetBase(const RetBase& from);
  
  inline RetBase& operator=(const RetBase& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RetBase& default_instance();
  
  void Swap(RetBase* other);
  
  // implements Message ----------------------------------------------
  
  RetBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RetBase& from);
  void MergeFrom(const RetBase& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 retcode = 1;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetcodeFieldNumber = 1;
  inline ::google::protobuf::int32 retcode() const;
  inline void set_retcode(::google::protobuf::int32 value);
  
  // optional string retmsg = 2;
  inline bool has_retmsg() const;
  inline void clear_retmsg();
  static const int kRetmsgFieldNumber = 2;
  inline const ::std::string& retmsg() const;
  inline void set_retmsg(const ::std::string& value);
  inline void set_retmsg(const char* value);
  inline void set_retmsg(const char* value, size_t size);
  inline ::std::string* mutable_retmsg();
  inline ::std::string* release_retmsg();
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.RetBase)
 private:
  inline void set_has_retcode();
  inline void clear_has_retcode();
  inline void set_has_retmsg();
  inline void clear_has_retmsg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* retmsg_;
  ::google::protobuf::int32 retcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fbase_2eproto();
  friend void protobuf_AssignDesc_adv_5fbase_2eproto();
  friend void protobuf_ShutdownFile_adv_5fbase_2eproto();
  
  void InitAsDefaultInstance();
  static RetBase* default_instance_;
};
// -------------------------------------------------------------------

class TaskInfo : public ::google::protobuf::Message {
 public:
  TaskInfo();
  virtual ~TaskInfo();
  
  TaskInfo(const TaskInfo& from);
  
  inline TaskInfo& operator=(const TaskInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskInfo& default_instance();
  
  void Swap(TaskInfo* other);
  
  // implements Message ----------------------------------------------
  
  TaskInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskInfo& from);
  void MergeFrom(const TaskInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline ::google::protobuf::int64 taskid() const;
  inline void set_taskid(::google::protobuf::int64 value);
  
  // required int32 tasktype = 2;
  inline bool has_tasktype() const;
  inline void clear_tasktype();
  static const int kTasktypeFieldNumber = 2;
  inline ::google::protobuf::int32 tasktype() const;
  inline void set_tasktype(::google::protobuf::int32 value);
  
  // required string taskname = 3;
  inline bool has_taskname() const;
  inline void clear_taskname();
  static const int kTasknameFieldNumber = 3;
  inline const ::std::string& taskname() const;
  inline void set_taskname(const ::std::string& value);
  inline void set_taskname(const char* value);
  inline void set_taskname(const char* value, size_t size);
  inline ::std::string* mutable_taskname();
  inline ::std::string* release_taskname();
  
  // required string tasklink = 4;
  inline bool has_tasklink() const;
  inline void clear_tasklink();
  static const int kTasklinkFieldNumber = 4;
  inline const ::std::string& tasklink() const;
  inline void set_tasklink(const ::std::string& value);
  inline void set_tasklink(const char* value);
  inline void set_tasklink(const char* value, size_t size);
  inline ::std::string* mutable_tasklink();
  inline ::std::string* release_tasklink();
  
  // required string taskdesc = 5;
  inline bool has_taskdesc() const;
  inline void clear_taskdesc();
  static const int kTaskdescFieldNumber = 5;
  inline const ::std::string& taskdesc() const;
  inline void set_taskdesc(const ::std::string& value);
  inline void set_taskdesc(const char* value);
  inline void set_taskdesc(const char* value, size_t size);
  inline ::std::string* mutable_taskdesc();
  inline ::std::string* release_taskdesc();
  
  // required int32 tasksize = 6;
  inline bool has_tasksize() const;
  inline void clear_tasksize();
  static const int kTasksizeFieldNumber = 6;
  inline ::google::protobuf::int32 tasksize() const;
  inline void set_tasksize(::google::protobuf::int32 value);
  
  // required string taskprice = 7;
  inline bool has_taskprice() const;
  inline void clear_taskprice();
  static const int kTaskpriceFieldNumber = 7;
  inline const ::std::string& taskprice() const;
  inline void set_taskprice(const ::std::string& value);
  inline void set_taskprice(const char* value);
  inline void set_taskprice(const char* value, size_t size);
  inline ::std::string* mutable_taskprice();
  inline ::std::string* release_taskprice();
  
  // optional int32 taskptstep = 8;
  inline bool has_taskptstep() const;
  inline void clear_taskptstep();
  static const int kTaskptstepFieldNumber = 8;
  inline ::google::protobuf::int32 taskptstep() const;
  inline void set_taskptstep(::google::protobuf::int32 value);
  
  // optional int32 taskpcstep = 9;
  inline bool has_taskpcstep() const;
  inline void clear_taskpcstep();
  static const int kTaskpcstepFieldNumber = 9;
  inline ::google::protobuf::int32 taskpcstep() const;
  inline void set_taskpcstep(::google::protobuf::int32 value);
  
  // optional string taskpublisher = 10;
  inline bool has_taskpublisher() const;
  inline void clear_taskpublisher();
  static const int kTaskpublisherFieldNumber = 10;
  inline const ::std::string& taskpublisher() const;
  inline void set_taskpublisher(const ::std::string& value);
  inline void set_taskpublisher(const char* value);
  inline void set_taskpublisher(const char* value, size_t size);
  inline ::std::string* mutable_taskpublisher();
  inline ::std::string* release_taskpublisher();
  
  // optional int32 tasktotalnum = 11;
  inline bool has_tasktotalnum() const;
  inline void clear_tasktotalnum();
  static const int kTasktotalnumFieldNumber = 11;
  inline ::google::protobuf::int32 tasktotalnum() const;
  inline void set_tasktotalnum(::google::protobuf::int32 value);
  
  // optional int32 taskusednum = 12;
  inline bool has_taskusednum() const;
  inline void clear_taskusednum();
  static const int kTaskusednumFieldNumber = 12;
  inline ::google::protobuf::int32 taskusednum() const;
  inline void set_taskusednum(::google::protobuf::int32 value);
  
  // optional int64 taskstime = 13;
  inline bool has_taskstime() const;
  inline void clear_taskstime();
  static const int kTaskstimeFieldNumber = 13;
  inline ::google::protobuf::int64 taskstime() const;
  inline void set_taskstime(::google::protobuf::int64 value);
  
  // optional int64 tasketime = 14;
  inline bool has_tasketime() const;
  inline void clear_tasketime();
  static const int kTasketimeFieldNumber = 14;
  inline ::google::protobuf::int64 tasketime() const;
  inline void set_tasketime(::google::protobuf::int64 value);
  
  // optional int32 taskstatus = 15;
  inline bool has_taskstatus() const;
  inline void clear_taskstatus();
  static const int kTaskstatusFieldNumber = 15;
  inline ::google::protobuf::int32 taskstatus() const;
  inline void set_taskstatus(::google::protobuf::int32 value);
  
  // optional string taskicon = 16;
  inline bool has_taskicon() const;
  inline void clear_taskicon();
  static const int kTaskiconFieldNumber = 16;
  inline const ::std::string& taskicon() const;
  inline void set_taskicon(const ::std::string& value);
  inline void set_taskicon(const char* value);
  inline void set_taskicon(const char* value, size_t size);
  inline ::std::string* mutable_taskicon();
  inline ::std::string* release_taskicon();
  
  // optional string taskpkgname = 17;
  inline bool has_taskpkgname() const;
  inline void clear_taskpkgname();
  static const int kTaskpkgnameFieldNumber = 17;
  inline const ::std::string& taskpkgname() const;
  inline void set_taskpkgname(const ::std::string& value);
  inline void set_taskpkgname(const char* value);
  inline void set_taskpkgname(const char* value, size_t size);
  inline ::std::string* mutable_taskpkgname();
  inline ::std::string* release_taskpkgname();
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.TaskInfo)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_tasktype();
  inline void clear_has_tasktype();
  inline void set_has_taskname();
  inline void clear_has_taskname();
  inline void set_has_tasklink();
  inline void clear_has_tasklink();
  inline void set_has_taskdesc();
  inline void clear_has_taskdesc();
  inline void set_has_tasksize();
  inline void clear_has_tasksize();
  inline void set_has_taskprice();
  inline void clear_has_taskprice();
  inline void set_has_taskptstep();
  inline void clear_has_taskptstep();
  inline void set_has_taskpcstep();
  inline void clear_has_taskpcstep();
  inline void set_has_taskpublisher();
  inline void clear_has_taskpublisher();
  inline void set_has_tasktotalnum();
  inline void clear_has_tasktotalnum();
  inline void set_has_taskusednum();
  inline void clear_has_taskusednum();
  inline void set_has_taskstime();
  inline void clear_has_taskstime();
  inline void set_has_tasketime();
  inline void clear_has_tasketime();
  inline void set_has_taskstatus();
  inline void clear_has_taskstatus();
  inline void set_has_taskicon();
  inline void clear_has_taskicon();
  inline void set_has_taskpkgname();
  inline void clear_has_taskpkgname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 taskid_;
  ::std::string* taskname_;
  ::std::string* tasklink_;
  ::google::protobuf::int32 tasktype_;
  ::google::protobuf::int32 tasksize_;
  ::std::string* taskdesc_;
  ::std::string* taskprice_;
  ::google::protobuf::int32 taskptstep_;
  ::google::protobuf::int32 taskpcstep_;
  ::std::string* taskpublisher_;
  ::google::protobuf::int32 tasktotalnum_;
  ::google::protobuf::int32 taskusednum_;
  ::google::protobuf::int64 taskstime_;
  ::google::protobuf::int64 tasketime_;
  ::std::string* taskicon_;
  ::std::string* taskpkgname_;
  ::google::protobuf::int32 taskstatus_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fbase_2eproto();
  friend void protobuf_AssignDesc_adv_5fbase_2eproto();
  friend void protobuf_ShutdownFile_adv_5fbase_2eproto();
  
  void InitAsDefaultInstance();
  static TaskInfo* default_instance_;
};
// -------------------------------------------------------------------

class PField : public ::google::protobuf::Message {
 public:
  PField();
  virtual ~PField();
  
  PField(const PField& from);
  
  inline PField& operator=(const PField& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PField& default_instance();
  
  void Swap(PField* other);
  
  // implements Message ----------------------------------------------
  
  PField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PField& from);
  void MergeFrom(const PField& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // required int32 valuetype = 3;
  inline bool has_valuetype() const;
  inline void clear_valuetype();
  static const int kValuetypeFieldNumber = 3;
  inline ::google::protobuf::int32 valuetype() const;
  inline void set_valuetype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.PField)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_valuetype();
  inline void clear_has_valuetype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* value_;
  ::google::protobuf::int32 valuetype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fbase_2eproto();
  friend void protobuf_AssignDesc_adv_5fbase_2eproto();
  friend void protobuf_ShutdownFile_adv_5fbase_2eproto();
  
  void InitAsDefaultInstance();
  static PField* default_instance_;
};
// -------------------------------------------------------------------

class PRow : public ::google::protobuf::Message {
 public:
  PRow();
  virtual ~PRow();
  
  PRow(const PRow& from);
  
  inline PRow& operator=(const PRow& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PRow& default_instance();
  
  void Swap(PRow* other);
  
  // implements Message ----------------------------------------------
  
  PRow* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PRow& from);
  void MergeFrom(const PRow& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 fieldnum = 1;
  inline bool has_fieldnum() const;
  inline void clear_fieldnum();
  static const int kFieldnumFieldNumber = 1;
  inline ::google::protobuf::int32 fieldnum() const;
  inline void set_fieldnum(::google::protobuf::int32 value);
  
  // repeated .com.adv.msg.PField field = 2;
  inline int field_size() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 2;
  inline const ::com::adv::msg::PField& field(int index) const;
  inline ::com::adv::msg::PField* mutable_field(int index);
  inline ::com::adv::msg::PField* add_field();
  inline const ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PField >&
      field() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PField >*
      mutable_field();
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.PRow)
 private:
  inline void set_has_fieldnum();
  inline void clear_has_fieldnum();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PField > field_;
  ::google::protobuf::int32 fieldnum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fbase_2eproto();
  friend void protobuf_AssignDesc_adv_5fbase_2eproto();
  friend void protobuf_ShutdownFile_adv_5fbase_2eproto();
  
  void InitAsDefaultInstance();
  static PRow* default_instance_;
};
// -------------------------------------------------------------------

class PDataCell : public ::google::protobuf::Message {
 public:
  PDataCell();
  virtual ~PDataCell();
  
  PDataCell(const PDataCell& from);
  
  inline PDataCell& operator=(const PDataCell& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PDataCell& default_instance();
  
  void Swap(PDataCell* other);
  
  // implements Message ----------------------------------------------
  
  PDataCell* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PDataCell& from);
  void MergeFrom(const PDataCell& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  
  // optional string str_value = 2;
  inline bool has_str_value() const;
  inline void clear_str_value();
  static const int kStrValueFieldNumber = 2;
  inline const ::std::string& str_value() const;
  inline void set_str_value(const ::std::string& value);
  inline void set_str_value(const char* value);
  inline void set_str_value(const char* value, size_t size);
  inline ::std::string* mutable_str_value();
  inline ::std::string* release_str_value();
  
  // optional int32 i32_value = 3;
  inline bool has_i32_value() const;
  inline void clear_i32_value();
  static const int kI32ValueFieldNumber = 3;
  inline ::google::protobuf::int32 i32_value() const;
  inline void set_i32_value(::google::protobuf::int32 value);
  
  // optional int64 i64_value = 4;
  inline bool has_i64_value() const;
  inline void clear_i64_value();
  static const int kI64ValueFieldNumber = 4;
  inline ::google::protobuf::int64 i64_value() const;
  inline void set_i64_value(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.PDataCell)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_str_value();
  inline void clear_has_str_value();
  inline void set_has_i32_value();
  inline void clear_has_i32_value();
  inline void set_has_i64_value();
  inline void clear_has_i64_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* tag_;
  ::std::string* str_value_;
  ::google::protobuf::int64 i64_value_;
  ::google::protobuf::int32 i32_value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fbase_2eproto();
  friend void protobuf_AssignDesc_adv_5fbase_2eproto();
  friend void protobuf_ShutdownFile_adv_5fbase_2eproto();
  
  void InitAsDefaultInstance();
  static PDataCell* default_instance_;
};
// ===================================================================


// ===================================================================

// RetBase

// required int32 retcode = 1;
inline bool RetBase::has_retcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetBase::set_has_retcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetBase::clear_has_retcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetBase::clear_retcode() {
  retcode_ = 0;
  clear_has_retcode();
}
inline ::google::protobuf::int32 RetBase::retcode() const {
  return retcode_;
}
inline void RetBase::set_retcode(::google::protobuf::int32 value) {
  set_has_retcode();
  retcode_ = value;
}

// optional string retmsg = 2;
inline bool RetBase::has_retmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetBase::set_has_retmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetBase::clear_has_retmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetBase::clear_retmsg() {
  if (retmsg_ != &::google::protobuf::internal::kEmptyString) {
    retmsg_->clear();
  }
  clear_has_retmsg();
}
inline const ::std::string& RetBase::retmsg() const {
  return *retmsg_;
}
inline void RetBase::set_retmsg(const ::std::string& value) {
  set_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    retmsg_ = new ::std::string;
  }
  retmsg_->assign(value);
}
inline void RetBase::set_retmsg(const char* value) {
  set_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    retmsg_ = new ::std::string;
  }
  retmsg_->assign(value);
}
inline void RetBase::set_retmsg(const char* value, size_t size) {
  set_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    retmsg_ = new ::std::string;
  }
  retmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RetBase::mutable_retmsg() {
  set_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    retmsg_ = new ::std::string;
  }
  return retmsg_;
}
inline ::std::string* RetBase::release_retmsg() {
  clear_has_retmsg();
  if (retmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = retmsg_;
    retmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TaskInfo

// required int64 taskid = 1;
inline bool TaskInfo::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskInfo::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskInfo::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskInfo::clear_taskid() {
  taskid_ = GOOGLE_LONGLONG(0);
  clear_has_taskid();
}
inline ::google::protobuf::int64 TaskInfo::taskid() const {
  return taskid_;
}
inline void TaskInfo::set_taskid(::google::protobuf::int64 value) {
  set_has_taskid();
  taskid_ = value;
}

// required int32 tasktype = 2;
inline bool TaskInfo::has_tasktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskInfo::set_has_tasktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskInfo::clear_has_tasktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskInfo::clear_tasktype() {
  tasktype_ = 0;
  clear_has_tasktype();
}
inline ::google::protobuf::int32 TaskInfo::tasktype() const {
  return tasktype_;
}
inline void TaskInfo::set_tasktype(::google::protobuf::int32 value) {
  set_has_tasktype();
  tasktype_ = value;
}

// required string taskname = 3;
inline bool TaskInfo::has_taskname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskInfo::set_has_taskname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskInfo::clear_has_taskname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskInfo::clear_taskname() {
  if (taskname_ != &::google::protobuf::internal::kEmptyString) {
    taskname_->clear();
  }
  clear_has_taskname();
}
inline const ::std::string& TaskInfo::taskname() const {
  return *taskname_;
}
inline void TaskInfo::set_taskname(const ::std::string& value) {
  set_has_taskname();
  if (taskname_ == &::google::protobuf::internal::kEmptyString) {
    taskname_ = new ::std::string;
  }
  taskname_->assign(value);
}
inline void TaskInfo::set_taskname(const char* value) {
  set_has_taskname();
  if (taskname_ == &::google::protobuf::internal::kEmptyString) {
    taskname_ = new ::std::string;
  }
  taskname_->assign(value);
}
inline void TaskInfo::set_taskname(const char* value, size_t size) {
  set_has_taskname();
  if (taskname_ == &::google::protobuf::internal::kEmptyString) {
    taskname_ = new ::std::string;
  }
  taskname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskInfo::mutable_taskname() {
  set_has_taskname();
  if (taskname_ == &::google::protobuf::internal::kEmptyString) {
    taskname_ = new ::std::string;
  }
  return taskname_;
}
inline ::std::string* TaskInfo::release_taskname() {
  clear_has_taskname();
  if (taskname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskname_;
    taskname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string tasklink = 4;
inline bool TaskInfo::has_tasklink() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskInfo::set_has_tasklink() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskInfo::clear_has_tasklink() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskInfo::clear_tasklink() {
  if (tasklink_ != &::google::protobuf::internal::kEmptyString) {
    tasklink_->clear();
  }
  clear_has_tasklink();
}
inline const ::std::string& TaskInfo::tasklink() const {
  return *tasklink_;
}
inline void TaskInfo::set_tasklink(const ::std::string& value) {
  set_has_tasklink();
  if (tasklink_ == &::google::protobuf::internal::kEmptyString) {
    tasklink_ = new ::std::string;
  }
  tasklink_->assign(value);
}
inline void TaskInfo::set_tasklink(const char* value) {
  set_has_tasklink();
  if (tasklink_ == &::google::protobuf::internal::kEmptyString) {
    tasklink_ = new ::std::string;
  }
  tasklink_->assign(value);
}
inline void TaskInfo::set_tasklink(const char* value, size_t size) {
  set_has_tasklink();
  if (tasklink_ == &::google::protobuf::internal::kEmptyString) {
    tasklink_ = new ::std::string;
  }
  tasklink_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskInfo::mutable_tasklink() {
  set_has_tasklink();
  if (tasklink_ == &::google::protobuf::internal::kEmptyString) {
    tasklink_ = new ::std::string;
  }
  return tasklink_;
}
inline ::std::string* TaskInfo::release_tasklink() {
  clear_has_tasklink();
  if (tasklink_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tasklink_;
    tasklink_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string taskdesc = 5;
inline bool TaskInfo::has_taskdesc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskInfo::set_has_taskdesc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskInfo::clear_has_taskdesc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskInfo::clear_taskdesc() {
  if (taskdesc_ != &::google::protobuf::internal::kEmptyString) {
    taskdesc_->clear();
  }
  clear_has_taskdesc();
}
inline const ::std::string& TaskInfo::taskdesc() const {
  return *taskdesc_;
}
inline void TaskInfo::set_taskdesc(const ::std::string& value) {
  set_has_taskdesc();
  if (taskdesc_ == &::google::protobuf::internal::kEmptyString) {
    taskdesc_ = new ::std::string;
  }
  taskdesc_->assign(value);
}
inline void TaskInfo::set_taskdesc(const char* value) {
  set_has_taskdesc();
  if (taskdesc_ == &::google::protobuf::internal::kEmptyString) {
    taskdesc_ = new ::std::string;
  }
  taskdesc_->assign(value);
}
inline void TaskInfo::set_taskdesc(const char* value, size_t size) {
  set_has_taskdesc();
  if (taskdesc_ == &::google::protobuf::internal::kEmptyString) {
    taskdesc_ = new ::std::string;
  }
  taskdesc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskInfo::mutable_taskdesc() {
  set_has_taskdesc();
  if (taskdesc_ == &::google::protobuf::internal::kEmptyString) {
    taskdesc_ = new ::std::string;
  }
  return taskdesc_;
}
inline ::std::string* TaskInfo::release_taskdesc() {
  clear_has_taskdesc();
  if (taskdesc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskdesc_;
    taskdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 tasksize = 6;
inline bool TaskInfo::has_tasksize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskInfo::set_has_tasksize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskInfo::clear_has_tasksize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskInfo::clear_tasksize() {
  tasksize_ = 0;
  clear_has_tasksize();
}
inline ::google::protobuf::int32 TaskInfo::tasksize() const {
  return tasksize_;
}
inline void TaskInfo::set_tasksize(::google::protobuf::int32 value) {
  set_has_tasksize();
  tasksize_ = value;
}

// required string taskprice = 7;
inline bool TaskInfo::has_taskprice() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TaskInfo::set_has_taskprice() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TaskInfo::clear_has_taskprice() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TaskInfo::clear_taskprice() {
  if (taskprice_ != &::google::protobuf::internal::kEmptyString) {
    taskprice_->clear();
  }
  clear_has_taskprice();
}
inline const ::std::string& TaskInfo::taskprice() const {
  return *taskprice_;
}
inline void TaskInfo::set_taskprice(const ::std::string& value) {
  set_has_taskprice();
  if (taskprice_ == &::google::protobuf::internal::kEmptyString) {
    taskprice_ = new ::std::string;
  }
  taskprice_->assign(value);
}
inline void TaskInfo::set_taskprice(const char* value) {
  set_has_taskprice();
  if (taskprice_ == &::google::protobuf::internal::kEmptyString) {
    taskprice_ = new ::std::string;
  }
  taskprice_->assign(value);
}
inline void TaskInfo::set_taskprice(const char* value, size_t size) {
  set_has_taskprice();
  if (taskprice_ == &::google::protobuf::internal::kEmptyString) {
    taskprice_ = new ::std::string;
  }
  taskprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskInfo::mutable_taskprice() {
  set_has_taskprice();
  if (taskprice_ == &::google::protobuf::internal::kEmptyString) {
    taskprice_ = new ::std::string;
  }
  return taskprice_;
}
inline ::std::string* TaskInfo::release_taskprice() {
  clear_has_taskprice();
  if (taskprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskprice_;
    taskprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 taskptstep = 8;
inline bool TaskInfo::has_taskptstep() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TaskInfo::set_has_taskptstep() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TaskInfo::clear_has_taskptstep() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TaskInfo::clear_taskptstep() {
  taskptstep_ = 0;
  clear_has_taskptstep();
}
inline ::google::protobuf::int32 TaskInfo::taskptstep() const {
  return taskptstep_;
}
inline void TaskInfo::set_taskptstep(::google::protobuf::int32 value) {
  set_has_taskptstep();
  taskptstep_ = value;
}

// optional int32 taskpcstep = 9;
inline bool TaskInfo::has_taskpcstep() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TaskInfo::set_has_taskpcstep() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TaskInfo::clear_has_taskpcstep() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TaskInfo::clear_taskpcstep() {
  taskpcstep_ = 0;
  clear_has_taskpcstep();
}
inline ::google::protobuf::int32 TaskInfo::taskpcstep() const {
  return taskpcstep_;
}
inline void TaskInfo::set_taskpcstep(::google::protobuf::int32 value) {
  set_has_taskpcstep();
  taskpcstep_ = value;
}

// optional string taskpublisher = 10;
inline bool TaskInfo::has_taskpublisher() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TaskInfo::set_has_taskpublisher() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TaskInfo::clear_has_taskpublisher() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TaskInfo::clear_taskpublisher() {
  if (taskpublisher_ != &::google::protobuf::internal::kEmptyString) {
    taskpublisher_->clear();
  }
  clear_has_taskpublisher();
}
inline const ::std::string& TaskInfo::taskpublisher() const {
  return *taskpublisher_;
}
inline void TaskInfo::set_taskpublisher(const ::std::string& value) {
  set_has_taskpublisher();
  if (taskpublisher_ == &::google::protobuf::internal::kEmptyString) {
    taskpublisher_ = new ::std::string;
  }
  taskpublisher_->assign(value);
}
inline void TaskInfo::set_taskpublisher(const char* value) {
  set_has_taskpublisher();
  if (taskpublisher_ == &::google::protobuf::internal::kEmptyString) {
    taskpublisher_ = new ::std::string;
  }
  taskpublisher_->assign(value);
}
inline void TaskInfo::set_taskpublisher(const char* value, size_t size) {
  set_has_taskpublisher();
  if (taskpublisher_ == &::google::protobuf::internal::kEmptyString) {
    taskpublisher_ = new ::std::string;
  }
  taskpublisher_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskInfo::mutable_taskpublisher() {
  set_has_taskpublisher();
  if (taskpublisher_ == &::google::protobuf::internal::kEmptyString) {
    taskpublisher_ = new ::std::string;
  }
  return taskpublisher_;
}
inline ::std::string* TaskInfo::release_taskpublisher() {
  clear_has_taskpublisher();
  if (taskpublisher_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskpublisher_;
    taskpublisher_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 tasktotalnum = 11;
inline bool TaskInfo::has_tasktotalnum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TaskInfo::set_has_tasktotalnum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TaskInfo::clear_has_tasktotalnum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TaskInfo::clear_tasktotalnum() {
  tasktotalnum_ = 0;
  clear_has_tasktotalnum();
}
inline ::google::protobuf::int32 TaskInfo::tasktotalnum() const {
  return tasktotalnum_;
}
inline void TaskInfo::set_tasktotalnum(::google::protobuf::int32 value) {
  set_has_tasktotalnum();
  tasktotalnum_ = value;
}

// optional int32 taskusednum = 12;
inline bool TaskInfo::has_taskusednum() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TaskInfo::set_has_taskusednum() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TaskInfo::clear_has_taskusednum() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TaskInfo::clear_taskusednum() {
  taskusednum_ = 0;
  clear_has_taskusednum();
}
inline ::google::protobuf::int32 TaskInfo::taskusednum() const {
  return taskusednum_;
}
inline void TaskInfo::set_taskusednum(::google::protobuf::int32 value) {
  set_has_taskusednum();
  taskusednum_ = value;
}

// optional int64 taskstime = 13;
inline bool TaskInfo::has_taskstime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TaskInfo::set_has_taskstime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TaskInfo::clear_has_taskstime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TaskInfo::clear_taskstime() {
  taskstime_ = GOOGLE_LONGLONG(0);
  clear_has_taskstime();
}
inline ::google::protobuf::int64 TaskInfo::taskstime() const {
  return taskstime_;
}
inline void TaskInfo::set_taskstime(::google::protobuf::int64 value) {
  set_has_taskstime();
  taskstime_ = value;
}

// optional int64 tasketime = 14;
inline bool TaskInfo::has_tasketime() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TaskInfo::set_has_tasketime() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TaskInfo::clear_has_tasketime() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TaskInfo::clear_tasketime() {
  tasketime_ = GOOGLE_LONGLONG(0);
  clear_has_tasketime();
}
inline ::google::protobuf::int64 TaskInfo::tasketime() const {
  return tasketime_;
}
inline void TaskInfo::set_tasketime(::google::protobuf::int64 value) {
  set_has_tasketime();
  tasketime_ = value;
}

// optional int32 taskstatus = 15;
inline bool TaskInfo::has_taskstatus() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TaskInfo::set_has_taskstatus() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TaskInfo::clear_has_taskstatus() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TaskInfo::clear_taskstatus() {
  taskstatus_ = 0;
  clear_has_taskstatus();
}
inline ::google::protobuf::int32 TaskInfo::taskstatus() const {
  return taskstatus_;
}
inline void TaskInfo::set_taskstatus(::google::protobuf::int32 value) {
  set_has_taskstatus();
  taskstatus_ = value;
}

// optional string taskicon = 16;
inline bool TaskInfo::has_taskicon() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TaskInfo::set_has_taskicon() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TaskInfo::clear_has_taskicon() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TaskInfo::clear_taskicon() {
  if (taskicon_ != &::google::protobuf::internal::kEmptyString) {
    taskicon_->clear();
  }
  clear_has_taskicon();
}
inline const ::std::string& TaskInfo::taskicon() const {
  return *taskicon_;
}
inline void TaskInfo::set_taskicon(const ::std::string& value) {
  set_has_taskicon();
  if (taskicon_ == &::google::protobuf::internal::kEmptyString) {
    taskicon_ = new ::std::string;
  }
  taskicon_->assign(value);
}
inline void TaskInfo::set_taskicon(const char* value) {
  set_has_taskicon();
  if (taskicon_ == &::google::protobuf::internal::kEmptyString) {
    taskicon_ = new ::std::string;
  }
  taskicon_->assign(value);
}
inline void TaskInfo::set_taskicon(const char* value, size_t size) {
  set_has_taskicon();
  if (taskicon_ == &::google::protobuf::internal::kEmptyString) {
    taskicon_ = new ::std::string;
  }
  taskicon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskInfo::mutable_taskicon() {
  set_has_taskicon();
  if (taskicon_ == &::google::protobuf::internal::kEmptyString) {
    taskicon_ = new ::std::string;
  }
  return taskicon_;
}
inline ::std::string* TaskInfo::release_taskicon() {
  clear_has_taskicon();
  if (taskicon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskicon_;
    taskicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string taskpkgname = 17;
inline bool TaskInfo::has_taskpkgname() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TaskInfo::set_has_taskpkgname() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TaskInfo::clear_has_taskpkgname() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TaskInfo::clear_taskpkgname() {
  if (taskpkgname_ != &::google::protobuf::internal::kEmptyString) {
    taskpkgname_->clear();
  }
  clear_has_taskpkgname();
}
inline const ::std::string& TaskInfo::taskpkgname() const {
  return *taskpkgname_;
}
inline void TaskInfo::set_taskpkgname(const ::std::string& value) {
  set_has_taskpkgname();
  if (taskpkgname_ == &::google::protobuf::internal::kEmptyString) {
    taskpkgname_ = new ::std::string;
  }
  taskpkgname_->assign(value);
}
inline void TaskInfo::set_taskpkgname(const char* value) {
  set_has_taskpkgname();
  if (taskpkgname_ == &::google::protobuf::internal::kEmptyString) {
    taskpkgname_ = new ::std::string;
  }
  taskpkgname_->assign(value);
}
inline void TaskInfo::set_taskpkgname(const char* value, size_t size) {
  set_has_taskpkgname();
  if (taskpkgname_ == &::google::protobuf::internal::kEmptyString) {
    taskpkgname_ = new ::std::string;
  }
  taskpkgname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskInfo::mutable_taskpkgname() {
  set_has_taskpkgname();
  if (taskpkgname_ == &::google::protobuf::internal::kEmptyString) {
    taskpkgname_ = new ::std::string;
  }
  return taskpkgname_;
}
inline ::std::string* TaskInfo::release_taskpkgname() {
  clear_has_taskpkgname();
  if (taskpkgname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = taskpkgname_;
    taskpkgname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PField

// required string name = 1;
inline bool PField::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PField::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PField::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PField::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PField::name() const {
  return *name_;
}
inline void PField::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PField::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PField::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PField::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PField::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string value = 2;
inline bool PField::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PField::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PField::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PField::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& PField::value() const {
  return *value_;
}
inline void PField::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void PField::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void PField::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PField::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* PField::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 valuetype = 3;
inline bool PField::has_valuetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PField::set_has_valuetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PField::clear_has_valuetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PField::clear_valuetype() {
  valuetype_ = 0;
  clear_has_valuetype();
}
inline ::google::protobuf::int32 PField::valuetype() const {
  return valuetype_;
}
inline void PField::set_valuetype(::google::protobuf::int32 value) {
  set_has_valuetype();
  valuetype_ = value;
}

// -------------------------------------------------------------------

// PRow

// required int32 fieldnum = 1;
inline bool PRow::has_fieldnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PRow::set_has_fieldnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PRow::clear_has_fieldnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PRow::clear_fieldnum() {
  fieldnum_ = 0;
  clear_has_fieldnum();
}
inline ::google::protobuf::int32 PRow::fieldnum() const {
  return fieldnum_;
}
inline void PRow::set_fieldnum(::google::protobuf::int32 value) {
  set_has_fieldnum();
  fieldnum_ = value;
}

// repeated .com.adv.msg.PField field = 2;
inline int PRow::field_size() const {
  return field_.size();
}
inline void PRow::clear_field() {
  field_.Clear();
}
inline const ::com::adv::msg::PField& PRow::field(int index) const {
  return field_.Get(index);
}
inline ::com::adv::msg::PField* PRow::mutable_field(int index) {
  return field_.Mutable(index);
}
inline ::com::adv::msg::PField* PRow::add_field() {
  return field_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PField >&
PRow::field() const {
  return field_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PField >*
PRow::mutable_field() {
  return &field_;
}

// -------------------------------------------------------------------

// PDataCell

// required string tag = 1;
inline bool PDataCell::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PDataCell::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PDataCell::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PDataCell::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& PDataCell::tag() const {
  return *tag_;
}
inline void PDataCell::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void PDataCell::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void PDataCell::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PDataCell::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* PDataCell::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string str_value = 2;
inline bool PDataCell::has_str_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PDataCell::set_has_str_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PDataCell::clear_has_str_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PDataCell::clear_str_value() {
  if (str_value_ != &::google::protobuf::internal::kEmptyString) {
    str_value_->clear();
  }
  clear_has_str_value();
}
inline const ::std::string& PDataCell::str_value() const {
  return *str_value_;
}
inline void PDataCell::set_str_value(const ::std::string& value) {
  set_has_str_value();
  if (str_value_ == &::google::protobuf::internal::kEmptyString) {
    str_value_ = new ::std::string;
  }
  str_value_->assign(value);
}
inline void PDataCell::set_str_value(const char* value) {
  set_has_str_value();
  if (str_value_ == &::google::protobuf::internal::kEmptyString) {
    str_value_ = new ::std::string;
  }
  str_value_->assign(value);
}
inline void PDataCell::set_str_value(const char* value, size_t size) {
  set_has_str_value();
  if (str_value_ == &::google::protobuf::internal::kEmptyString) {
    str_value_ = new ::std::string;
  }
  str_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PDataCell::mutable_str_value() {
  set_has_str_value();
  if (str_value_ == &::google::protobuf::internal::kEmptyString) {
    str_value_ = new ::std::string;
  }
  return str_value_;
}
inline ::std::string* PDataCell::release_str_value() {
  clear_has_str_value();
  if (str_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_value_;
    str_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 i32_value = 3;
inline bool PDataCell::has_i32_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PDataCell::set_has_i32_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PDataCell::clear_has_i32_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PDataCell::clear_i32_value() {
  i32_value_ = 0;
  clear_has_i32_value();
}
inline ::google::protobuf::int32 PDataCell::i32_value() const {
  return i32_value_;
}
inline void PDataCell::set_i32_value(::google::protobuf::int32 value) {
  set_has_i32_value();
  i32_value_ = value;
}

// optional int64 i64_value = 4;
inline bool PDataCell::has_i64_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PDataCell::set_has_i64_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PDataCell::clear_has_i64_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PDataCell::clear_i64_value() {
  i64_value_ = GOOGLE_LONGLONG(0);
  clear_has_i64_value();
}
inline ::google::protobuf::int64 PDataCell::i64_value() const {
  return i64_value_;
}
inline void PDataCell::set_i64_value(::google::protobuf::int64 value) {
  set_has_i64_value();
  i64_value_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg
}  // namespace adv
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_adv_5fbase_2eproto__INCLUDED
