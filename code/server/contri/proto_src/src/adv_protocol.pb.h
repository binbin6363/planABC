// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: adv_protocol.proto

#ifndef PROTOBUF_adv_5fprotocol_2eproto__INCLUDED
#define PROTOBUF_adv_5fprotocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "adv_base.pb.h"
// @@protoc_insertion_point(includes)

namespace com {
namespace adv {
namespace msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_adv_5fprotocol_2eproto();
void protobuf_AssignDesc_adv_5fprotocol_2eproto();
void protobuf_ShutdownFile_adv_5fprotocol_2eproto();

class UserKeepAliveRequest;
class LoginRequest;
class LoginResult;
class LogoutRequest;
class LogoutResult;
class TaskNotify;
class SyncTaskRequest;
class SyncTaskResult;
class ReportTaskRequest;
class ReportTaskResult;
class GetIncomeRequest;
class GetIncomeResult;
class AckRequest;
class SaveTaskRequest;
class SaveTaskResult;
class WithdrawRequest;
class WithdrawResult;
class MysqlRequest;
class MysqlResult;
class RedispRequest;
class RedispResult;
class InnerCommonMsg;

// ===================================================================

class UserKeepAliveRequest : public ::google::protobuf::Message {
 public:
  UserKeepAliveRequest();
  virtual ~UserKeepAliveRequest();
  
  UserKeepAliveRequest(const UserKeepAliveRequest& from);
  
  inline UserKeepAliveRequest& operator=(const UserKeepAliveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserKeepAliveRequest& default_instance();
  
  void Swap(UserKeepAliveRequest* other);
  
  // implements Message ----------------------------------------------
  
  UserKeepAliveRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserKeepAliveRequest& from);
  void MergeFrom(const UserKeepAliveRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 condid = 1;
  inline bool has_condid() const;
  inline void clear_condid();
  static const int kCondidFieldNumber = 1;
  inline ::google::protobuf::int32 condid() const;
  inline void set_condid(::google::protobuf::int32 value);
  
  // required int32 devicetype = 2;
  inline bool has_devicetype() const;
  inline void clear_devicetype();
  static const int kDevicetypeFieldNumber = 2;
  inline ::google::protobuf::int32 devicetype() const;
  inline void set_devicetype(::google::protobuf::int32 value);
  
  // optional string deviceid = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 3;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  
  // optional int32 uid = 4;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 4;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);
  
  // optional int32 version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.UserKeepAliveRequest)
 private:
  inline void set_has_condid();
  inline void clear_has_condid();
  inline void set_has_devicetype();
  inline void clear_has_devicetype();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 condid_;
  ::google::protobuf::int32 devicetype_;
  ::std::string* deviceid_;
  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static UserKeepAliveRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();
  
  LoginRequest(const LoginRequest& from);
  
  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();
  
  void Swap(LoginRequest* other);
  
  // implements Message ----------------------------------------------
  
  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // optional int32 magicnum = 2;
  inline bool has_magicnum() const;
  inline void clear_magicnum();
  static const int kMagicnumFieldNumber = 2;
  inline ::google::protobuf::int32 magicnum() const;
  inline void set_magicnum(::google::protobuf::int32 value);
  
  // optional int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // required int32 devicetype = 4;
  inline bool has_devicetype() const;
  inline void clear_devicetype();
  static const int kDevicetypeFieldNumber = 4;
  inline ::google::protobuf::int32 devicetype() const;
  inline void set_devicetype(::google::protobuf::int32 value);
  
  // required string deviceid = 6;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 6;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  
  // optional string description = 7;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 7;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // required int32 condid = 8;
  inline bool has_condid() const;
  inline void clear_condid();
  static const int kCondidFieldNumber = 8;
  inline ::google::protobuf::int32 condid() const;
  inline void set_condid(::google::protobuf::int32 value);
  
  // optional int32 loginseq = 9;
  inline bool has_loginseq() const;
  inline void clear_loginseq();
  static const int kLoginseqFieldNumber = 9;
  inline ::google::protobuf::int32 loginseq() const;
  inline void set_loginseq(::google::protobuf::int32 value);
  
  // optional int32 accounttype = 10;
  inline bool has_accounttype() const;
  inline void clear_accounttype();
  static const int kAccounttypeFieldNumber = 10;
  inline ::google::protobuf::int32 accounttype() const;
  inline void set_accounttype(::google::protobuf::int32 value);
  
  // optional string account = 11;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 11;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  
  // optional string passwd = 12;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 12;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  
  // optional int32 version = 13;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 13;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // optional string nickname = 14;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 14;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  
  // optional int32 gender = 15;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 15;
  inline ::google::protobuf::int32 gender() const;
  inline void set_gender(::google::protobuf::int32 value);
  
  // optional string province = 16;
  inline bool has_province() const;
  inline void clear_province();
  static const int kProvinceFieldNumber = 16;
  inline const ::std::string& province() const;
  inline void set_province(const ::std::string& value);
  inline void set_province(const char* value);
  inline void set_province(const char* value, size_t size);
  inline ::std::string* mutable_province();
  inline ::std::string* release_province();
  
  // optional string city = 17;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 17;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  
  // optional string country = 18;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 18;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  
  // optional string avatar = 19;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 19;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  
  // optional string desc = 20;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 20;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  
  // optional string email = 21;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 21;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  
  // optional string mobile = 22;
  inline bool has_mobile() const;
  inline void clear_mobile();
  static const int kMobileFieldNumber = 22;
  inline const ::std::string& mobile() const;
  inline void set_mobile(const ::std::string& value);
  inline void set_mobile(const char* value);
  inline void set_mobile(const char* value, size_t size);
  inline ::std::string* mutable_mobile();
  inline ::std::string* release_mobile();
  
  // optional int32 time = 23;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 23;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);
  
  // optional int32 uid = 24;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 24;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);
  
  // optional int32 flag = 25;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 25;
  inline ::google::protobuf::int32 flag() const;
  inline void set_flag(::google::protobuf::int32 value);
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.LoginRequest)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_magicnum();
  inline void clear_has_magicnum();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_devicetype();
  inline void clear_has_devicetype();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_condid();
  inline void clear_has_condid();
  inline void set_has_loginseq();
  inline void clear_has_loginseq();
  inline void set_has_accounttype();
  inline void clear_has_accounttype();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_province();
  inline void clear_has_province();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_mobile();
  inline void clear_has_mobile();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* token_;
  ::google::protobuf::int32 magicnum_;
  ::google::protobuf::int32 status_;
  ::std::string* deviceid_;
  ::google::protobuf::int32 devicetype_;
  ::google::protobuf::int32 condid_;
  ::std::string* description_;
  ::google::protobuf::int32 loginseq_;
  ::google::protobuf::int32 accounttype_;
  ::std::string* account_;
  ::std::string* passwd_;
  ::std::string* nickname_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 gender_;
  ::std::string* province_;
  ::std::string* city_;
  ::std::string* country_;
  ::std::string* avatar_;
  ::std::string* desc_;
  ::std::string* email_;
  ::std::string* mobile_;
  ::google::protobuf::int32 time_;
  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 flag_;
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(25 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResult : public ::google::protobuf::Message {
 public:
  LoginResult();
  virtual ~LoginResult();
  
  LoginResult(const LoginResult& from);
  
  inline LoginResult& operator=(const LoginResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResult& default_instance();
  
  void Swap(LoginResult* other);
  
  // implements Message ----------------------------------------------
  
  LoginResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResult& from);
  void MergeFrom(const LoginResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.adv.msg.RetBase retbase = 1;
  inline bool has_retbase() const;
  inline void clear_retbase();
  static const int kRetbaseFieldNumber = 1;
  inline const ::com::adv::msg::RetBase& retbase() const;
  inline ::com::adv::msg::RetBase* mutable_retbase();
  inline ::com::adv::msg::RetBase* release_retbase();
  
  // optional string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional int32 uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);
  
  // optional int32 loginseq = 4;
  inline bool has_loginseq() const;
  inline void clear_loginseq();
  static const int kLoginseqFieldNumber = 4;
  inline ::google::protobuf::int32 loginseq() const;
  inline void set_loginseq(::google::protobuf::int32 value);
  
  // optional int32 accounttype = 5;
  inline bool has_accounttype() const;
  inline void clear_accounttype();
  static const int kAccounttypeFieldNumber = 5;
  inline ::google::protobuf::int32 accounttype() const;
  inline void set_accounttype(::google::protobuf::int32 value);
  
  // optional int32 time = 6;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 6;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.LoginResult)
 private:
  inline void set_has_retbase();
  inline void clear_has_retbase();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_loginseq();
  inline void clear_has_loginseq();
  inline void set_has_accounttype();
  inline void clear_has_accounttype();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::adv::msg::RetBase* retbase_;
  ::std::string* key_;
  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 loginseq_;
  ::google::protobuf::int32 accounttype_;
  ::google::protobuf::int32 time_;
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static LoginResult* default_instance_;
};
// -------------------------------------------------------------------

class LogoutRequest : public ::google::protobuf::Message {
 public:
  LogoutRequest();
  virtual ~LogoutRequest();
  
  LogoutRequest(const LogoutRequest& from);
  
  inline LogoutRequest& operator=(const LogoutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutRequest& default_instance();
  
  void Swap(LogoutRequest* other);
  
  // implements Message ----------------------------------------------
  
  LogoutRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutRequest& from);
  void MergeFrom(const LogoutRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 deviceType = 1;
  inline bool has_devicetype() const;
  inline void clear_devicetype();
  static const int kDeviceTypeFieldNumber = 1;
  inline ::google::protobuf::int32 devicetype() const;
  inline void set_devicetype(::google::protobuf::int32 value);
  
  // required string deviceid = 2;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 2;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  
  // required int32 conid = 3;
  inline bool has_conid() const;
  inline void clear_conid();
  static const int kConidFieldNumber = 3;
  inline ::google::protobuf::int32 conid() const;
  inline void set_conid(::google::protobuf::int32 value);
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.LogoutRequest)
 private:
  inline void set_has_devicetype();
  inline void clear_has_devicetype();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_conid();
  inline void clear_has_conid();
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* deviceid_;
  ::google::protobuf::int32 devicetype_;
  ::google::protobuf::int32 conid_;
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static LogoutRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogoutResult : public ::google::protobuf::Message {
 public:
  LogoutResult();
  virtual ~LogoutResult();
  
  LogoutResult(const LogoutResult& from);
  
  inline LogoutResult& operator=(const LogoutResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutResult& default_instance();
  
  void Swap(LogoutResult* other);
  
  // implements Message ----------------------------------------------
  
  LogoutResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutResult& from);
  void MergeFrom(const LogoutResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.adv.msg.RetBase retbase = 1;
  inline bool has_retbase() const;
  inline void clear_retbase();
  static const int kRetbaseFieldNumber = 1;
  inline const ::com::adv::msg::RetBase& retbase() const;
  inline ::com::adv::msg::RetBase* mutable_retbase();
  inline ::com::adv::msg::RetBase* release_retbase();
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.LogoutResult)
 private:
  inline void set_has_retbase();
  inline void clear_has_retbase();
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::adv::msg::RetBase* retbase_;
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static LogoutResult* default_instance_;
};
// -------------------------------------------------------------------

class TaskNotify : public ::google::protobuf::Message {
 public:
  TaskNotify();
  virtual ~TaskNotify();
  
  TaskNotify(const TaskNotify& from);
  
  inline TaskNotify& operator=(const TaskNotify& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskNotify& default_instance();
  
  void Swap(TaskNotify* other);
  
  // implements Message ----------------------------------------------
  
  TaskNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskNotify& from);
  void MergeFrom(const TaskNotify& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 tasktype = 1;
  inline bool has_tasktype() const;
  inline void clear_tasktype();
  static const int kTasktypeFieldNumber = 1;
  inline ::google::protobuf::int32 tasktype() const;
  inline void set_tasktype(::google::protobuf::int32 value);
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.TaskNotify)
 private:
  inline void set_has_tasktype();
  inline void clear_has_tasktype();
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 tasktype_;
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static TaskNotify* default_instance_;
};
// -------------------------------------------------------------------

class SyncTaskRequest : public ::google::protobuf::Message {
 public:
  SyncTaskRequest();
  virtual ~SyncTaskRequest();
  
  SyncTaskRequest(const SyncTaskRequest& from);
  
  inline SyncTaskRequest& operator=(const SyncTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncTaskRequest& default_instance();
  
  void Swap(SyncTaskRequest* other);
  
  // implements Message ----------------------------------------------
  
  SyncTaskRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncTaskRequest& from);
  void MergeFrom(const SyncTaskRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 syncpoint = 1;
  inline bool has_syncpoint() const;
  inline void clear_syncpoint();
  static const int kSyncpointFieldNumber = 1;
  inline ::google::protobuf::int64 syncpoint() const;
  inline void set_syncpoint(::google::protobuf::int64 value);
  
  // required int32 synctype = 2;
  inline bool has_synctype() const;
  inline void clear_synctype();
  static const int kSynctypeFieldNumber = 2;
  inline ::google::protobuf::int32 synctype() const;
  inline void set_synctype(::google::protobuf::int32 value);
  
  // optional int32 syncflag = 3;
  inline bool has_syncflag() const;
  inline void clear_syncflag();
  static const int kSyncflagFieldNumber = 3;
  inline ::google::protobuf::int32 syncflag() const;
  inline void set_syncflag(::google::protobuf::int32 value);
  
  // optional int32 synclimit = 4;
  inline bool has_synclimit() const;
  inline void clear_synclimit();
  static const int kSynclimitFieldNumber = 4;
  inline ::google::protobuf::int32 synclimit() const;
  inline void set_synclimit(::google::protobuf::int32 value);
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.SyncTaskRequest)
 private:
  inline void set_has_syncpoint();
  inline void clear_has_syncpoint();
  inline void set_has_synctype();
  inline void clear_has_synctype();
  inline void set_has_syncflag();
  inline void clear_has_syncflag();
  inline void set_has_synclimit();
  inline void clear_has_synclimit();
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 syncpoint_;
  ::google::protobuf::int32 synctype_;
  ::google::protobuf::int32 syncflag_;
  ::google::protobuf::int32 synclimit_;
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static SyncTaskRequest* default_instance_;
};
// -------------------------------------------------------------------

class SyncTaskResult : public ::google::protobuf::Message {
 public:
  SyncTaskResult();
  virtual ~SyncTaskResult();
  
  SyncTaskResult(const SyncTaskResult& from);
  
  inline SyncTaskResult& operator=(const SyncTaskResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncTaskResult& default_instance();
  
  void Swap(SyncTaskResult* other);
  
  // implements Message ----------------------------------------------
  
  SyncTaskResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncTaskResult& from);
  void MergeFrom(const SyncTaskResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.adv.msg.RetBase retbase = 1;
  inline bool has_retbase() const;
  inline void clear_retbase();
  static const int kRetbaseFieldNumber = 1;
  inline const ::com::adv::msg::RetBase& retbase() const;
  inline ::com::adv::msg::RetBase* mutable_retbase();
  inline ::com::adv::msg::RetBase* release_retbase();
  
  // repeated .com.adv.msg.TaskInfo taskinfos = 2;
  inline int taskinfos_size() const;
  inline void clear_taskinfos();
  static const int kTaskinfosFieldNumber = 2;
  inline const ::com::adv::msg::TaskInfo& taskinfos(int index) const;
  inline ::com::adv::msg::TaskInfo* mutable_taskinfos(int index);
  inline ::com::adv::msg::TaskInfo* add_taskinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::com::adv::msg::TaskInfo >&
      taskinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::adv::msg::TaskInfo >*
      mutable_taskinfos();
  
  // required int32 synctype = 3;
  inline bool has_synctype() const;
  inline void clear_synctype();
  static const int kSynctypeFieldNumber = 3;
  inline ::google::protobuf::int32 synctype() const;
  inline void set_synctype(::google::protobuf::int32 value);
  
  // optional int32 continueflag = 4;
  inline bool has_continueflag() const;
  inline void clear_continueflag();
  static const int kContinueflagFieldNumber = 4;
  inline ::google::protobuf::int32 continueflag() const;
  inline void set_continueflag(::google::protobuf::int32 value);
  
  // optional int64 maxtaskid = 5;
  inline bool has_maxtaskid() const;
  inline void clear_maxtaskid();
  static const int kMaxtaskidFieldNumber = 5;
  inline ::google::protobuf::int64 maxtaskid() const;
  inline void set_maxtaskid(::google::protobuf::int64 value);
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.SyncTaskResult)
 private:
  inline void set_has_retbase();
  inline void clear_has_retbase();
  inline void set_has_synctype();
  inline void clear_has_synctype();
  inline void set_has_continueflag();
  inline void clear_has_continueflag();
  inline void set_has_maxtaskid();
  inline void clear_has_maxtaskid();
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::adv::msg::RetBase* retbase_;
  ::google::protobuf::RepeatedPtrField< ::com::adv::msg::TaskInfo > taskinfos_;
  ::google::protobuf::int32 synctype_;
  ::google::protobuf::int32 continueflag_;
  ::google::protobuf::int64 maxtaskid_;
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static SyncTaskResult* default_instance_;
};
// -------------------------------------------------------------------

class ReportTaskRequest : public ::google::protobuf::Message {
 public:
  ReportTaskRequest();
  virtual ~ReportTaskRequest();
  
  ReportTaskRequest(const ReportTaskRequest& from);
  
  inline ReportTaskRequest& operator=(const ReportTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportTaskRequest& default_instance();
  
  void Swap(ReportTaskRequest* other);
  
  // implements Message ----------------------------------------------
  
  ReportTaskRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReportTaskRequest& from);
  void MergeFrom(const ReportTaskRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.adv.msg.TaskInfo taskinfo = 1;
  inline bool has_taskinfo() const;
  inline void clear_taskinfo();
  static const int kTaskinfoFieldNumber = 1;
  inline const ::com::adv::msg::TaskInfo& taskinfo() const;
  inline ::com::adv::msg::TaskInfo* mutable_taskinfo();
  inline ::com::adv::msg::TaskInfo* release_taskinfo();
  
  // optional string reward = 2;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 2;
  inline const ::std::string& reward() const;
  inline void set_reward(const ::std::string& value);
  inline void set_reward(const char* value);
  inline void set_reward(const char* value, size_t size);
  inline ::std::string* mutable_reward();
  inline ::std::string* release_reward();
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.ReportTaskRequest)
 private:
  inline void set_has_taskinfo();
  inline void clear_has_taskinfo();
  inline void set_has_reward();
  inline void clear_has_reward();
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::adv::msg::TaskInfo* taskinfo_;
  ::std::string* reward_;
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static ReportTaskRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReportTaskResult : public ::google::protobuf::Message {
 public:
  ReportTaskResult();
  virtual ~ReportTaskResult();
  
  ReportTaskResult(const ReportTaskResult& from);
  
  inline ReportTaskResult& operator=(const ReportTaskResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportTaskResult& default_instance();
  
  void Swap(ReportTaskResult* other);
  
  // implements Message ----------------------------------------------
  
  ReportTaskResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReportTaskResult& from);
  void MergeFrom(const ReportTaskResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.adv.msg.RetBase retbase = 1;
  inline bool has_retbase() const;
  inline void clear_retbase();
  static const int kRetbaseFieldNumber = 1;
  inline const ::com::adv::msg::RetBase& retbase() const;
  inline ::com::adv::msg::RetBase* mutable_retbase();
  inline ::com::adv::msg::RetBase* release_retbase();
  
  // required int64 taskid = 2;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 2;
  inline ::google::protobuf::int64 taskid() const;
  inline void set_taskid(::google::protobuf::int64 value);
  
  // required string reward = 3;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 3;
  inline const ::std::string& reward() const;
  inline void set_reward(const ::std::string& value);
  inline void set_reward(const char* value);
  inline void set_reward(const char* value, size_t size);
  inline ::std::string* mutable_reward();
  inline ::std::string* release_reward();
  
  // optional int32 done_step = 4;
  inline bool has_done_step() const;
  inline void clear_done_step();
  static const int kDoneStepFieldNumber = 4;
  inline ::google::protobuf::int32 done_step() const;
  inline void set_done_step(::google::protobuf::int32 value);
  
  // optional int32 tasktype = 5;
  inline bool has_tasktype() const;
  inline void clear_tasktype();
  static const int kTasktypeFieldNumber = 5;
  inline ::google::protobuf::int32 tasktype() const;
  inline void set_tasktype(::google::protobuf::int32 value);
  
  // optional int32 report_time = 6;
  inline bool has_report_time() const;
  inline void clear_report_time();
  static const int kReportTimeFieldNumber = 6;
  inline ::google::protobuf::int32 report_time() const;
  inline void set_report_time(::google::protobuf::int32 value);
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.ReportTaskResult)
 private:
  inline void set_has_retbase();
  inline void clear_has_retbase();
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_reward();
  inline void clear_has_reward();
  inline void set_has_done_step();
  inline void clear_has_done_step();
  inline void set_has_tasktype();
  inline void clear_has_tasktype();
  inline void set_has_report_time();
  inline void clear_has_report_time();
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::adv::msg::RetBase* retbase_;
  ::google::protobuf::int64 taskid_;
  ::std::string* reward_;
  ::google::protobuf::int32 done_step_;
  ::google::protobuf::int32 tasktype_;
  ::google::protobuf::int32 report_time_;
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static ReportTaskResult* default_instance_;
};
// -------------------------------------------------------------------

class GetIncomeRequest : public ::google::protobuf::Message {
 public:
  GetIncomeRequest();
  virtual ~GetIncomeRequest();
  
  GetIncomeRequest(const GetIncomeRequest& from);
  
  inline GetIncomeRequest& operator=(const GetIncomeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetIncomeRequest& default_instance();
  
  void Swap(GetIncomeRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetIncomeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetIncomeRequest& from);
  void MergeFrom(const GetIncomeRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.GetIncomeRequest)
 private:
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static GetIncomeRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetIncomeResult : public ::google::protobuf::Message {
 public:
  GetIncomeResult();
  virtual ~GetIncomeResult();
  
  GetIncomeResult(const GetIncomeResult& from);
  
  inline GetIncomeResult& operator=(const GetIncomeResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetIncomeResult& default_instance();
  
  void Swap(GetIncomeResult* other);
  
  // implements Message ----------------------------------------------
  
  GetIncomeResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetIncomeResult& from);
  void MergeFrom(const GetIncomeResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.adv.msg.RetBase retbase = 1;
  inline bool has_retbase() const;
  inline void clear_retbase();
  static const int kRetbaseFieldNumber = 1;
  inline const ::com::adv::msg::RetBase& retbase() const;
  inline ::com::adv::msg::RetBase* mutable_retbase();
  inline ::com::adv::msg::RetBase* release_retbase();
  
  // required string pre_cash = 2;
  inline bool has_pre_cash() const;
  inline void clear_pre_cash();
  static const int kPreCashFieldNumber = 2;
  inline const ::std::string& pre_cash() const;
  inline void set_pre_cash(const ::std::string& value);
  inline void set_pre_cash(const char* value);
  inline void set_pre_cash(const char* value, size_t size);
  inline ::std::string* mutable_pre_cash();
  inline ::std::string* release_pre_cash();
  
  // required string useable_cash = 3;
  inline bool has_useable_cash() const;
  inline void clear_useable_cash();
  static const int kUseableCashFieldNumber = 3;
  inline const ::std::string& useable_cash() const;
  inline void set_useable_cash(const ::std::string& value);
  inline void set_useable_cash(const char* value);
  inline void set_useable_cash(const char* value, size_t size);
  inline ::std::string* mutable_useable_cash();
  inline ::std::string* release_useable_cash();
  
  // required string fetched_cash = 4;
  inline bool has_fetched_cash() const;
  inline void clear_fetched_cash();
  static const int kFetchedCashFieldNumber = 4;
  inline const ::std::string& fetched_cash() const;
  inline void set_fetched_cash(const ::std::string& value);
  inline void set_fetched_cash(const char* value);
  inline void set_fetched_cash(const char* value, size_t size);
  inline ::std::string* mutable_fetched_cash();
  inline ::std::string* release_fetched_cash();
  
  // optional int32 rank = 5;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 5;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);
  
  // optional string desc = 6;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 6;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.GetIncomeResult)
 private:
  inline void set_has_retbase();
  inline void clear_has_retbase();
  inline void set_has_pre_cash();
  inline void clear_has_pre_cash();
  inline void set_has_useable_cash();
  inline void clear_has_useable_cash();
  inline void set_has_fetched_cash();
  inline void clear_has_fetched_cash();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::adv::msg::RetBase* retbase_;
  ::std::string* pre_cash_;
  ::std::string* useable_cash_;
  ::std::string* fetched_cash_;
  ::std::string* desc_;
  ::google::protobuf::int32 rank_;
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static GetIncomeResult* default_instance_;
};
// -------------------------------------------------------------------

class AckRequest : public ::google::protobuf::Message {
 public:
  AckRequest();
  virtual ~AckRequest();
  
  AckRequest(const AckRequest& from);
  
  inline AckRequest& operator=(const AckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckRequest& default_instance();
  
  void Swap(AckRequest* other);
  
  // implements Message ----------------------------------------------
  
  AckRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckRequest& from);
  void MergeFrom(const AckRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // repeated int64 id = 2;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int64 id(int index) const;
  inline void set_id(int index, ::google::protobuf::int64 value);
  inline void add_id(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_id();
  
  // optional int32 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.AckRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > id_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 time_;
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static AckRequest* default_instance_;
};
// -------------------------------------------------------------------

class SaveTaskRequest : public ::google::protobuf::Message {
 public:
  SaveTaskRequest();
  virtual ~SaveTaskRequest();
  
  SaveTaskRequest(const SaveTaskRequest& from);
  
  inline SaveTaskRequest& operator=(const SaveTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SaveTaskRequest& default_instance();
  
  void Swap(SaveTaskRequest* other);
  
  // implements Message ----------------------------------------------
  
  SaveTaskRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SaveTaskRequest& from);
  void MergeFrom(const SaveTaskRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.adv.msg.TaskInfo taskinfo = 1;
  inline int taskinfo_size() const;
  inline void clear_taskinfo();
  static const int kTaskinfoFieldNumber = 1;
  inline const ::com::adv::msg::TaskInfo& taskinfo(int index) const;
  inline ::com::adv::msg::TaskInfo* mutable_taskinfo(int index);
  inline ::com::adv::msg::TaskInfo* add_taskinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::com::adv::msg::TaskInfo >&
      taskinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::adv::msg::TaskInfo >*
      mutable_taskinfo();
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.SaveTaskRequest)
 private:
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::adv::msg::TaskInfo > taskinfo_;
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static SaveTaskRequest* default_instance_;
};
// -------------------------------------------------------------------

class SaveTaskResult : public ::google::protobuf::Message {
 public:
  SaveTaskResult();
  virtual ~SaveTaskResult();
  
  SaveTaskResult(const SaveTaskResult& from);
  
  inline SaveTaskResult& operator=(const SaveTaskResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SaveTaskResult& default_instance();
  
  void Swap(SaveTaskResult* other);
  
  // implements Message ----------------------------------------------
  
  SaveTaskResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SaveTaskResult& from);
  void MergeFrom(const SaveTaskResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.adv.msg.RetBase retbase = 1;
  inline bool has_retbase() const;
  inline void clear_retbase();
  static const int kRetbaseFieldNumber = 1;
  inline const ::com::adv::msg::RetBase& retbase() const;
  inline ::com::adv::msg::RetBase* mutable_retbase();
  inline ::com::adv::msg::RetBase* release_retbase();
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.SaveTaskResult)
 private:
  inline void set_has_retbase();
  inline void clear_has_retbase();
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::adv::msg::RetBase* retbase_;
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static SaveTaskResult* default_instance_;
};
// -------------------------------------------------------------------

class WithdrawRequest : public ::google::protobuf::Message {
 public:
  WithdrawRequest();
  virtual ~WithdrawRequest();
  
  WithdrawRequest(const WithdrawRequest& from);
  
  inline WithdrawRequest& operator=(const WithdrawRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WithdrawRequest& default_instance();
  
  void Swap(WithdrawRequest* other);
  
  // implements Message ----------------------------------------------
  
  WithdrawRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WithdrawRequest& from);
  void MergeFrom(const WithdrawRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required int32 withdraw_cash = 2;
  inline bool has_withdraw_cash() const;
  inline void clear_withdraw_cash();
  static const int kWithdrawCashFieldNumber = 2;
  inline ::google::protobuf::int32 withdraw_cash() const;
  inline void set_withdraw_cash(::google::protobuf::int32 value);
  
  // required string id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required string open_id = 4;
  inline bool has_open_id() const;
  inline void clear_open_id();
  static const int kOpenIdFieldNumber = 4;
  inline const ::std::string& open_id() const;
  inline void set_open_id(const ::std::string& value);
  inline void set_open_id(const char* value);
  inline void set_open_id(const char* value, size_t size);
  inline ::std::string* mutable_open_id();
  inline ::std::string* release_open_id();
  
  // required string passwd = 5;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 5;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  
  // optional string user_name = 6;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 6;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  
  // optional string desc = 7;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 7;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  
  // optional int32 time = 8;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 8;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.WithdrawRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_withdraw_cash();
  inline void clear_has_withdraw_cash();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_open_id();
  inline void clear_has_open_id();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 withdraw_cash_;
  ::std::string* id_;
  ::std::string* open_id_;
  ::std::string* passwd_;
  ::std::string* user_name_;
  ::std::string* desc_;
  ::google::protobuf::int32 time_;
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static WithdrawRequest* default_instance_;
};
// -------------------------------------------------------------------

class WithdrawResult : public ::google::protobuf::Message {
 public:
  WithdrawResult();
  virtual ~WithdrawResult();
  
  WithdrawResult(const WithdrawResult& from);
  
  inline WithdrawResult& operator=(const WithdrawResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WithdrawResult& default_instance();
  
  void Swap(WithdrawResult* other);
  
  // implements Message ----------------------------------------------
  
  WithdrawResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WithdrawResult& from);
  void MergeFrom(const WithdrawResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.adv.msg.RetBase retbase = 1;
  inline bool has_retbase() const;
  inline void clear_retbase();
  static const int kRetbaseFieldNumber = 1;
  inline const ::com::adv::msg::RetBase& retbase() const;
  inline ::com::adv::msg::RetBase* mutable_retbase();
  inline ::com::adv::msg::RetBase* release_retbase();
  
  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required int32 withdraw_cash = 3;
  inline bool has_withdraw_cash() const;
  inline void clear_withdraw_cash();
  static const int kWithdrawCashFieldNumber = 3;
  inline ::google::protobuf::int32 withdraw_cash() const;
  inline void set_withdraw_cash(::google::protobuf::int32 value);
  
  // required string trade_id = 4;
  inline bool has_trade_id() const;
  inline void clear_trade_id();
  static const int kTradeIdFieldNumber = 4;
  inline const ::std::string& trade_id() const;
  inline void set_trade_id(const ::std::string& value);
  inline void set_trade_id(const char* value);
  inline void set_trade_id(const char* value, size_t size);
  inline ::std::string* mutable_trade_id();
  inline ::std::string* release_trade_id();
  
  // optional string desc = 5;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 5;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  
  // optional int32 time = 6;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 6;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);
  
  // optional string pre_cash = 7;
  inline bool has_pre_cash() const;
  inline void clear_pre_cash();
  static const int kPreCashFieldNumber = 7;
  inline const ::std::string& pre_cash() const;
  inline void set_pre_cash(const ::std::string& value);
  inline void set_pre_cash(const char* value);
  inline void set_pre_cash(const char* value, size_t size);
  inline ::std::string* mutable_pre_cash();
  inline ::std::string* release_pre_cash();
  
  // optional string useable_cash = 8;
  inline bool has_useable_cash() const;
  inline void clear_useable_cash();
  static const int kUseableCashFieldNumber = 8;
  inline const ::std::string& useable_cash() const;
  inline void set_useable_cash(const ::std::string& value);
  inline void set_useable_cash(const char* value);
  inline void set_useable_cash(const char* value, size_t size);
  inline ::std::string* mutable_useable_cash();
  inline ::std::string* release_useable_cash();
  
  // optional string fetched_cash = 9;
  inline bool has_fetched_cash() const;
  inline void clear_fetched_cash();
  static const int kFetchedCashFieldNumber = 9;
  inline const ::std::string& fetched_cash() const;
  inline void set_fetched_cash(const ::std::string& value);
  inline void set_fetched_cash(const char* value);
  inline void set_fetched_cash(const char* value, size_t size);
  inline ::std::string* mutable_fetched_cash();
  inline ::std::string* release_fetched_cash();
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.WithdrawResult)
 private:
  inline void set_has_retbase();
  inline void clear_has_retbase();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_withdraw_cash();
  inline void clear_has_withdraw_cash();
  inline void set_has_trade_id();
  inline void clear_has_trade_id();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_pre_cash();
  inline void clear_has_pre_cash();
  inline void set_has_useable_cash();
  inline void clear_has_useable_cash();
  inline void set_has_fetched_cash();
  inline void clear_has_fetched_cash();
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::adv::msg::RetBase* retbase_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 withdraw_cash_;
  ::std::string* trade_id_;
  ::std::string* desc_;
  ::std::string* pre_cash_;
  ::std::string* useable_cash_;
  ::google::protobuf::int32 time_;
  ::google::protobuf::int32 transid_;
  ::std::string* fetched_cash_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static WithdrawResult* default_instance_;
};
// -------------------------------------------------------------------

class MysqlRequest : public ::google::protobuf::Message {
 public:
  MysqlRequest();
  virtual ~MysqlRequest();
  
  MysqlRequest(const MysqlRequest& from);
  
  inline MysqlRequest& operator=(const MysqlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MysqlRequest& default_instance();
  
  void Swap(MysqlRequest* other);
  
  // implements Message ----------------------------------------------
  
  MysqlRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MysqlRequest& from);
  void MergeFrom(const MysqlRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 sqlid = 1;
  inline bool has_sqlid() const;
  inline void clear_sqlid();
  static const int kSqlidFieldNumber = 1;
  inline ::google::protobuf::int32 sqlid() const;
  inline void set_sqlid(::google::protobuf::int32 value);
  
  // required string sql = 2;
  inline bool has_sql() const;
  inline void clear_sql();
  static const int kSqlFieldNumber = 2;
  inline const ::std::string& sql() const;
  inline void set_sql(const ::std::string& value);
  inline void set_sql(const char* value);
  inline void set_sql(const char* value, size_t size);
  inline ::std::string* mutable_sql();
  inline ::std::string* release_sql();
  
  // optional int32 isrequestfield = 3;
  inline bool has_isrequestfield() const;
  inline void clear_isrequestfield();
  static const int kIsrequestfieldFieldNumber = 3;
  inline ::google::protobuf::int32 isrequestfield() const;
  inline void set_isrequestfield(::google::protobuf::int32 value);
  
  // optional int32 limit = 4;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 4;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);
  
  // optional int32 timeout = 5;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 5;
  inline ::google::protobuf::int32 timeout() const;
  inline void set_timeout(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.MysqlRequest)
 private:
  inline void set_has_sqlid();
  inline void clear_has_sqlid();
  inline void set_has_sql();
  inline void clear_has_sql();
  inline void set_has_isrequestfield();
  inline void clear_has_isrequestfield();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* sql_;
  ::google::protobuf::int32 sqlid_;
  ::google::protobuf::int32 isrequestfield_;
  ::google::protobuf::int32 limit_;
  ::google::protobuf::int32 timeout_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static MysqlRequest* default_instance_;
};
// -------------------------------------------------------------------

class MysqlResult : public ::google::protobuf::Message {
 public:
  MysqlResult();
  virtual ~MysqlResult();
  
  MysqlResult(const MysqlResult& from);
  
  inline MysqlResult& operator=(const MysqlResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MysqlResult& default_instance();
  
  void Swap(MysqlResult* other);
  
  // implements Message ----------------------------------------------
  
  MysqlResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MysqlResult& from);
  void MergeFrom(const MysqlResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.adv.msg.RetBase retbase = 1;
  inline bool has_retbase() const;
  inline void clear_retbase();
  static const int kRetbaseFieldNumber = 1;
  inline const ::com::adv::msg::RetBase& retbase() const;
  inline ::com::adv::msg::RetBase* mutable_retbase();
  inline ::com::adv::msg::RetBase* release_retbase();
  
  // optional int32 affectedrows = 2;
  inline bool has_affectedrows() const;
  inline void clear_affectedrows();
  static const int kAffectedrowsFieldNumber = 2;
  inline ::google::protobuf::int32 affectedrows() const;
  inline void set_affectedrows(::google::protobuf::int32 value);
  
  // optional int32 insertid = 3;
  inline bool has_insertid() const;
  inline void clear_insertid();
  static const int kInsertidFieldNumber = 3;
  inline ::google::protobuf::int32 insertid() const;
  inline void set_insertid(::google::protobuf::int32 value);
  
  // repeated .com.adv.msg.PRow rows = 4;
  inline int rows_size() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 4;
  inline const ::com::adv::msg::PRow& rows(int index) const;
  inline ::com::adv::msg::PRow* mutable_rows(int index);
  inline ::com::adv::msg::PRow* add_rows();
  inline const ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PRow >&
      rows() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PRow >*
      mutable_rows();
  
  // optional int32 sqlid = 5;
  inline bool has_sqlid() const;
  inline void clear_sqlid();
  static const int kSqlidFieldNumber = 5;
  inline ::google::protobuf::int32 sqlid() const;
  inline void set_sqlid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.MysqlResult)
 private:
  inline void set_has_retbase();
  inline void clear_has_retbase();
  inline void set_has_affectedrows();
  inline void clear_has_affectedrows();
  inline void set_has_insertid();
  inline void clear_has_insertid();
  inline void set_has_sqlid();
  inline void clear_has_sqlid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::adv::msg::RetBase* retbase_;
  ::google::protobuf::int32 affectedrows_;
  ::google::protobuf::int32 insertid_;
  ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PRow > rows_;
  ::google::protobuf::int32 sqlid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static MysqlResult* default_instance_;
};
// -------------------------------------------------------------------

class RedispRequest : public ::google::protobuf::Message {
 public:
  RedispRequest();
  virtual ~RedispRequest();
  
  RedispRequest(const RedispRequest& from);
  
  inline RedispRequest& operator=(const RedispRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RedispRequest& default_instance();
  
  void Swap(RedispRequest* other);
  
  // implements Message ----------------------------------------------
  
  RedispRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RedispRequest& from);
  void MergeFrom(const RedispRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 sqlid = 1;
  inline bool has_sqlid() const;
  inline void clear_sqlid();
  static const int kSqlidFieldNumber = 1;
  inline ::google::protobuf::int32 sqlid() const;
  inline void set_sqlid(::google::protobuf::int32 value);
  
  // required string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional int32 param = 3;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 3;
  inline ::google::protobuf::int32 param() const;
  inline void set_param(::google::protobuf::int32 value);
  
  // optional int32 limit = 4;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 4;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);
  
  // optional int32 timeout = 5;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 5;
  inline ::google::protobuf::int32 timeout() const;
  inline void set_timeout(::google::protobuf::int32 value);
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.RedispRequest)
 private:
  inline void set_has_sqlid();
  inline void clear_has_sqlid();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* key_;
  ::google::protobuf::int32 sqlid_;
  ::google::protobuf::int32 param_;
  ::google::protobuf::int32 limit_;
  ::google::protobuf::int32 timeout_;
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static RedispRequest* default_instance_;
};
// -------------------------------------------------------------------

class RedispResult : public ::google::protobuf::Message {
 public:
  RedispResult();
  virtual ~RedispResult();
  
  RedispResult(const RedispResult& from);
  
  inline RedispResult& operator=(const RedispResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RedispResult& default_instance();
  
  void Swap(RedispResult* other);
  
  // implements Message ----------------------------------------------
  
  RedispResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RedispResult& from);
  void MergeFrom(const RedispResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.adv.msg.RetBase retbase = 1;
  inline bool has_retbase() const;
  inline void clear_retbase();
  static const int kRetbaseFieldNumber = 1;
  inline const ::com::adv::msg::RetBase& retbase() const;
  inline ::com::adv::msg::RetBase* mutable_retbase();
  inline ::com::adv::msg::RetBase* release_retbase();
  
  // optional int32 affectedrows = 2;
  inline bool has_affectedrows() const;
  inline void clear_affectedrows();
  static const int kAffectedrowsFieldNumber = 2;
  inline ::google::protobuf::int32 affectedrows() const;
  inline void set_affectedrows(::google::protobuf::int32 value);
  
  // optional int32 insertid = 3;
  inline bool has_insertid() const;
  inline void clear_insertid();
  static const int kInsertidFieldNumber = 3;
  inline ::google::protobuf::int32 insertid() const;
  inline void set_insertid(::google::protobuf::int32 value);
  
  // repeated .com.adv.msg.PRow rows = 4;
  inline int rows_size() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 4;
  inline const ::com::adv::msg::PRow& rows(int index) const;
  inline ::com::adv::msg::PRow* mutable_rows(int index);
  inline ::com::adv::msg::PRow* add_rows();
  inline const ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PRow >&
      rows() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PRow >*
      mutable_rows();
  
  // optional int32 sqlid = 5;
  inline bool has_sqlid() const;
  inline void clear_sqlid();
  static const int kSqlidFieldNumber = 5;
  inline ::google::protobuf::int32 sqlid() const;
  inline void set_sqlid(::google::protobuf::int32 value);
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.RedispResult)
 private:
  inline void set_has_retbase();
  inline void clear_has_retbase();
  inline void set_has_affectedrows();
  inline void clear_has_affectedrows();
  inline void set_has_insertid();
  inline void clear_has_insertid();
  inline void set_has_sqlid();
  inline void clear_has_sqlid();
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::adv::msg::RetBase* retbase_;
  ::google::protobuf::int32 affectedrows_;
  ::google::protobuf::int32 insertid_;
  ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PRow > rows_;
  ::google::protobuf::int32 sqlid_;
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static RedispResult* default_instance_;
};
// -------------------------------------------------------------------

class InnerCommonMsg : public ::google::protobuf::Message {
 public:
  InnerCommonMsg();
  virtual ~InnerCommonMsg();
  
  InnerCommonMsg(const InnerCommonMsg& from);
  
  inline InnerCommonMsg& operator=(const InnerCommonMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InnerCommonMsg& default_instance();
  
  void Swap(InnerCommonMsg* other);
  
  // implements Message ----------------------------------------------
  
  InnerCommonMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InnerCommonMsg& from);
  void MergeFrom(const InnerCommonMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.adv.msg.PDataCell items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::com::adv::msg::PDataCell& items(int index) const;
  inline ::com::adv::msg::PDataCell* mutable_items(int index);
  inline ::com::adv::msg::PDataCell* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PDataCell >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PDataCell >*
      mutable_items();
  
  // optional string transfer = 2;
  inline bool has_transfer() const;
  inline void clear_transfer();
  static const int kTransferFieldNumber = 2;
  inline const ::std::string& transfer() const;
  inline void set_transfer(const ::std::string& value);
  inline void set_transfer(const char* value);
  inline void set_transfer(const char* value, size_t size);
  inline ::std::string* mutable_transfer();
  inline ::std::string* release_transfer();
  
  // optional int32 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);
  
  // optional int32 transid = 32;
  inline bool has_transid() const;
  inline void clear_transid();
  static const int kTransidFieldNumber = 32;
  inline ::google::protobuf::int32 transid() const;
  inline void set_transid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.adv.msg.InnerCommonMsg)
 private:
  inline void set_has_transfer();
  inline void clear_has_transfer();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_transid();
  inline void clear_has_transid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PDataCell > items_;
  ::std::string* transfer_;
  ::google::protobuf::int32 time_;
  ::google::protobuf::int32 transid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_adv_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_adv_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_adv_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static InnerCommonMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// UserKeepAliveRequest

// required int32 condid = 1;
inline bool UserKeepAliveRequest::has_condid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserKeepAliveRequest::set_has_condid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserKeepAliveRequest::clear_has_condid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserKeepAliveRequest::clear_condid() {
  condid_ = 0;
  clear_has_condid();
}
inline ::google::protobuf::int32 UserKeepAliveRequest::condid() const {
  return condid_;
}
inline void UserKeepAliveRequest::set_condid(::google::protobuf::int32 value) {
  set_has_condid();
  condid_ = value;
}

// required int32 devicetype = 2;
inline bool UserKeepAliveRequest::has_devicetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserKeepAliveRequest::set_has_devicetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserKeepAliveRequest::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserKeepAliveRequest::clear_devicetype() {
  devicetype_ = 0;
  clear_has_devicetype();
}
inline ::google::protobuf::int32 UserKeepAliveRequest::devicetype() const {
  return devicetype_;
}
inline void UserKeepAliveRequest::set_devicetype(::google::protobuf::int32 value) {
  set_has_devicetype();
  devicetype_ = value;
}

// optional string deviceid = 3;
inline bool UserKeepAliveRequest::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserKeepAliveRequest::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserKeepAliveRequest::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserKeepAliveRequest::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& UserKeepAliveRequest::deviceid() const {
  return *deviceid_;
}
inline void UserKeepAliveRequest::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void UserKeepAliveRequest::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void UserKeepAliveRequest::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserKeepAliveRequest::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* UserKeepAliveRequest::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 uid = 4;
inline bool UserKeepAliveRequest::has_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserKeepAliveRequest::set_has_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserKeepAliveRequest::clear_has_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserKeepAliveRequest::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 UserKeepAliveRequest::uid() const {
  return uid_;
}
inline void UserKeepAliveRequest::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 version = 5;
inline bool UserKeepAliveRequest::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserKeepAliveRequest::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserKeepAliveRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserKeepAliveRequest::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 UserKeepAliveRequest::version() const {
  return version_;
}
inline void UserKeepAliveRequest::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional int32 transid = 32;
inline bool UserKeepAliveRequest::has_transid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserKeepAliveRequest::set_has_transid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserKeepAliveRequest::clear_has_transid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserKeepAliveRequest::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 UserKeepAliveRequest::transid() const {
  return transid_;
}
inline void UserKeepAliveRequest::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// LoginRequest

// required string token = 1;
inline bool LoginRequest::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& LoginRequest::token() const {
  return *token_;
}
inline void LoginRequest::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void LoginRequest::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void LoginRequest::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* LoginRequest::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 magicnum = 2;
inline bool LoginRequest::has_magicnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_magicnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_magicnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_magicnum() {
  magicnum_ = 0;
  clear_has_magicnum();
}
inline ::google::protobuf::int32 LoginRequest::magicnum() const {
  return magicnum_;
}
inline void LoginRequest::set_magicnum(::google::protobuf::int32 value) {
  set_has_magicnum();
  magicnum_ = value;
}

// optional int32 status = 3;
inline bool LoginRequest::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequest::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequest::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 LoginRequest::status() const {
  return status_;
}
inline void LoginRequest::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// required int32 devicetype = 4;
inline bool LoginRequest::has_devicetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRequest::set_has_devicetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginRequest::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginRequest::clear_devicetype() {
  devicetype_ = 0;
  clear_has_devicetype();
}
inline ::google::protobuf::int32 LoginRequest::devicetype() const {
  return devicetype_;
}
inline void LoginRequest::set_devicetype(::google::protobuf::int32 value) {
  set_has_devicetype();
  devicetype_ = value;
}

// required string deviceid = 6;
inline bool LoginRequest::has_deviceid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginRequest::set_has_deviceid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginRequest::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginRequest::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& LoginRequest::deviceid() const {
  return *deviceid_;
}
inline void LoginRequest::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void LoginRequest::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void LoginRequest::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* LoginRequest::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string description = 7;
inline bool LoginRequest::has_description() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginRequest::set_has_description() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginRequest::clear_has_description() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginRequest::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& LoginRequest::description() const {
  return *description_;
}
inline void LoginRequest::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void LoginRequest::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void LoginRequest::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* LoginRequest::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 condid = 8;
inline bool LoginRequest::has_condid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginRequest::set_has_condid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginRequest::clear_has_condid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginRequest::clear_condid() {
  condid_ = 0;
  clear_has_condid();
}
inline ::google::protobuf::int32 LoginRequest::condid() const {
  return condid_;
}
inline void LoginRequest::set_condid(::google::protobuf::int32 value) {
  set_has_condid();
  condid_ = value;
}

// optional int32 loginseq = 9;
inline bool LoginRequest::has_loginseq() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginRequest::set_has_loginseq() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginRequest::clear_has_loginseq() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginRequest::clear_loginseq() {
  loginseq_ = 0;
  clear_has_loginseq();
}
inline ::google::protobuf::int32 LoginRequest::loginseq() const {
  return loginseq_;
}
inline void LoginRequest::set_loginseq(::google::protobuf::int32 value) {
  set_has_loginseq();
  loginseq_ = value;
}

// optional int32 accounttype = 10;
inline bool LoginRequest::has_accounttype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoginRequest::set_has_accounttype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoginRequest::clear_has_accounttype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoginRequest::clear_accounttype() {
  accounttype_ = 0;
  clear_has_accounttype();
}
inline ::google::protobuf::int32 LoginRequest::accounttype() const {
  return accounttype_;
}
inline void LoginRequest::set_accounttype(::google::protobuf::int32 value) {
  set_has_accounttype();
  accounttype_ = value;
}

// optional string account = 11;
inline bool LoginRequest::has_account() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LoginRequest::set_has_account() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LoginRequest::clear_has_account() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LoginRequest::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& LoginRequest::account() const {
  return *account_;
}
inline void LoginRequest::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void LoginRequest::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void LoginRequest::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* LoginRequest::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string passwd = 12;
inline bool LoginRequest::has_passwd() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LoginRequest::set_has_passwd() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LoginRequest::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LoginRequest::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& LoginRequest::passwd() const {
  return *passwd_;
}
inline void LoginRequest::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void LoginRequest::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void LoginRequest::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* LoginRequest::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 version = 13;
inline bool LoginRequest::has_version() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LoginRequest::set_has_version() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LoginRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LoginRequest::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 LoginRequest::version() const {
  return version_;
}
inline void LoginRequest::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional string nickname = 14;
inline bool LoginRequest::has_nickname() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LoginRequest::set_has_nickname() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LoginRequest::clear_has_nickname() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LoginRequest::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& LoginRequest::nickname() const {
  return *nickname_;
}
inline void LoginRequest::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void LoginRequest::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void LoginRequest::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* LoginRequest::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 gender = 15;
inline bool LoginRequest::has_gender() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LoginRequest::set_has_gender() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LoginRequest::clear_has_gender() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LoginRequest::clear_gender() {
  gender_ = 0;
  clear_has_gender();
}
inline ::google::protobuf::int32 LoginRequest::gender() const {
  return gender_;
}
inline void LoginRequest::set_gender(::google::protobuf::int32 value) {
  set_has_gender();
  gender_ = value;
}

// optional string province = 16;
inline bool LoginRequest::has_province() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LoginRequest::set_has_province() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LoginRequest::clear_has_province() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LoginRequest::clear_province() {
  if (province_ != &::google::protobuf::internal::kEmptyString) {
    province_->clear();
  }
  clear_has_province();
}
inline const ::std::string& LoginRequest::province() const {
  return *province_;
}
inline void LoginRequest::set_province(const ::std::string& value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    province_ = new ::std::string;
  }
  province_->assign(value);
}
inline void LoginRequest::set_province(const char* value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    province_ = new ::std::string;
  }
  province_->assign(value);
}
inline void LoginRequest::set_province(const char* value, size_t size) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    province_ = new ::std::string;
  }
  province_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_province() {
  set_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    province_ = new ::std::string;
  }
  return province_;
}
inline ::std::string* LoginRequest::release_province() {
  clear_has_province();
  if (province_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = province_;
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string city = 17;
inline bool LoginRequest::has_city() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void LoginRequest::set_has_city() {
  _has_bits_[0] |= 0x00008000u;
}
inline void LoginRequest::clear_has_city() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void LoginRequest::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& LoginRequest::city() const {
  return *city_;
}
inline void LoginRequest::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void LoginRequest::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void LoginRequest::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* LoginRequest::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string country = 18;
inline bool LoginRequest::has_country() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void LoginRequest::set_has_country() {
  _has_bits_[0] |= 0x00010000u;
}
inline void LoginRequest::clear_has_country() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void LoginRequest::clear_country() {
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& LoginRequest::country() const {
  return *country_;
}
inline void LoginRequest::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void LoginRequest::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void LoginRequest::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  return country_;
}
inline ::std::string* LoginRequest::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string avatar = 19;
inline bool LoginRequest::has_avatar() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void LoginRequest::set_has_avatar() {
  _has_bits_[0] |= 0x00020000u;
}
inline void LoginRequest::clear_has_avatar() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void LoginRequest::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& LoginRequest::avatar() const {
  return *avatar_;
}
inline void LoginRequest::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void LoginRequest::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void LoginRequest::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* LoginRequest::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string desc = 20;
inline bool LoginRequest::has_desc() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void LoginRequest::set_has_desc() {
  _has_bits_[0] |= 0x00040000u;
}
inline void LoginRequest::clear_has_desc() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void LoginRequest::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& LoginRequest::desc() const {
  return *desc_;
}
inline void LoginRequest::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void LoginRequest::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void LoginRequest::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* LoginRequest::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string email = 21;
inline bool LoginRequest::has_email() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void LoginRequest::set_has_email() {
  _has_bits_[0] |= 0x00080000u;
}
inline void LoginRequest::clear_has_email() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void LoginRequest::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& LoginRequest::email() const {
  return *email_;
}
inline void LoginRequest::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void LoginRequest::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void LoginRequest::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* LoginRequest::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string mobile = 22;
inline bool LoginRequest::has_mobile() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void LoginRequest::set_has_mobile() {
  _has_bits_[0] |= 0x00100000u;
}
inline void LoginRequest::clear_has_mobile() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void LoginRequest::clear_mobile() {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    mobile_->clear();
  }
  clear_has_mobile();
}
inline const ::std::string& LoginRequest::mobile() const {
  return *mobile_;
}
inline void LoginRequest::set_mobile(const ::std::string& value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void LoginRequest::set_mobile(const char* value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void LoginRequest::set_mobile(const char* value, size_t size) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_mobile() {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  return mobile_;
}
inline ::std::string* LoginRequest::release_mobile() {
  clear_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobile_;
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 time = 23;
inline bool LoginRequest::has_time() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void LoginRequest::set_has_time() {
  _has_bits_[0] |= 0x00200000u;
}
inline void LoginRequest::clear_has_time() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void LoginRequest::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 LoginRequest::time() const {
  return time_;
}
inline void LoginRequest::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// optional int32 uid = 24;
inline bool LoginRequest::has_uid() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void LoginRequest::set_has_uid() {
  _has_bits_[0] |= 0x00400000u;
}
inline void LoginRequest::clear_has_uid() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void LoginRequest::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 LoginRequest::uid() const {
  return uid_;
}
inline void LoginRequest::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 flag = 25;
inline bool LoginRequest::has_flag() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void LoginRequest::set_has_flag() {
  _has_bits_[0] |= 0x00800000u;
}
inline void LoginRequest::clear_has_flag() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void LoginRequest::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::google::protobuf::int32 LoginRequest::flag() const {
  return flag_;
}
inline void LoginRequest::set_flag(::google::protobuf::int32 value) {
  set_has_flag();
  flag_ = value;
}

// optional int32 transid = 32;
inline bool LoginRequest::has_transid() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void LoginRequest::set_has_transid() {
  _has_bits_[0] |= 0x01000000u;
}
inline void LoginRequest::clear_has_transid() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void LoginRequest::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 LoginRequest::transid() const {
  return transid_;
}
inline void LoginRequest::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// LoginResult

// required .com.adv.msg.RetBase retbase = 1;
inline bool LoginResult::has_retbase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResult::set_has_retbase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResult::clear_has_retbase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResult::clear_retbase() {
  if (retbase_ != NULL) retbase_->::com::adv::msg::RetBase::Clear();
  clear_has_retbase();
}
inline const ::com::adv::msg::RetBase& LoginResult::retbase() const {
  return retbase_ != NULL ? *retbase_ : *default_instance_->retbase_;
}
inline ::com::adv::msg::RetBase* LoginResult::mutable_retbase() {
  set_has_retbase();
  if (retbase_ == NULL) retbase_ = new ::com::adv::msg::RetBase;
  return retbase_;
}
inline ::com::adv::msg::RetBase* LoginResult::release_retbase() {
  clear_has_retbase();
  ::com::adv::msg::RetBase* temp = retbase_;
  retbase_ = NULL;
  return temp;
}

// optional string key = 2;
inline bool LoginResult::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResult::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResult::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResult::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& LoginResult::key() const {
  return *key_;
}
inline void LoginResult::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void LoginResult::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void LoginResult::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResult::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* LoginResult::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 uid = 3;
inline bool LoginResult::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResult::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResult::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResult::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 LoginResult::uid() const {
  return uid_;
}
inline void LoginResult::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 loginseq = 4;
inline bool LoginResult::has_loginseq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginResult::set_has_loginseq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginResult::clear_has_loginseq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginResult::clear_loginseq() {
  loginseq_ = 0;
  clear_has_loginseq();
}
inline ::google::protobuf::int32 LoginResult::loginseq() const {
  return loginseq_;
}
inline void LoginResult::set_loginseq(::google::protobuf::int32 value) {
  set_has_loginseq();
  loginseq_ = value;
}

// optional int32 accounttype = 5;
inline bool LoginResult::has_accounttype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginResult::set_has_accounttype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginResult::clear_has_accounttype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginResult::clear_accounttype() {
  accounttype_ = 0;
  clear_has_accounttype();
}
inline ::google::protobuf::int32 LoginResult::accounttype() const {
  return accounttype_;
}
inline void LoginResult::set_accounttype(::google::protobuf::int32 value) {
  set_has_accounttype();
  accounttype_ = value;
}

// optional int32 time = 6;
inline bool LoginResult::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginResult::set_has_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginResult::clear_has_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginResult::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 LoginResult::time() const {
  return time_;
}
inline void LoginResult::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// optional int32 transid = 32;
inline bool LoginResult::has_transid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginResult::set_has_transid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginResult::clear_has_transid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginResult::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 LoginResult::transid() const {
  return transid_;
}
inline void LoginResult::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// LogoutRequest

// required int32 deviceType = 1;
inline bool LogoutRequest::has_devicetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutRequest::set_has_devicetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutRequest::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutRequest::clear_devicetype() {
  devicetype_ = 0;
  clear_has_devicetype();
}
inline ::google::protobuf::int32 LogoutRequest::devicetype() const {
  return devicetype_;
}
inline void LogoutRequest::set_devicetype(::google::protobuf::int32 value) {
  set_has_devicetype();
  devicetype_ = value;
}

// required string deviceid = 2;
inline bool LogoutRequest::has_deviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogoutRequest::set_has_deviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogoutRequest::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogoutRequest::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& LogoutRequest::deviceid() const {
  return *deviceid_;
}
inline void LogoutRequest::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void LogoutRequest::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void LogoutRequest::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogoutRequest::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* LogoutRequest::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 conid = 3;
inline bool LogoutRequest::has_conid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogoutRequest::set_has_conid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogoutRequest::clear_has_conid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogoutRequest::clear_conid() {
  conid_ = 0;
  clear_has_conid();
}
inline ::google::protobuf::int32 LogoutRequest::conid() const {
  return conid_;
}
inline void LogoutRequest::set_conid(::google::protobuf::int32 value) {
  set_has_conid();
  conid_ = value;
}

// optional int32 transid = 32;
inline bool LogoutRequest::has_transid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogoutRequest::set_has_transid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogoutRequest::clear_has_transid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogoutRequest::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 LogoutRequest::transid() const {
  return transid_;
}
inline void LogoutRequest::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// LogoutResult

// required .com.adv.msg.RetBase retbase = 1;
inline bool LogoutResult::has_retbase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutResult::set_has_retbase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutResult::clear_has_retbase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutResult::clear_retbase() {
  if (retbase_ != NULL) retbase_->::com::adv::msg::RetBase::Clear();
  clear_has_retbase();
}
inline const ::com::adv::msg::RetBase& LogoutResult::retbase() const {
  return retbase_ != NULL ? *retbase_ : *default_instance_->retbase_;
}
inline ::com::adv::msg::RetBase* LogoutResult::mutable_retbase() {
  set_has_retbase();
  if (retbase_ == NULL) retbase_ = new ::com::adv::msg::RetBase;
  return retbase_;
}
inline ::com::adv::msg::RetBase* LogoutResult::release_retbase() {
  clear_has_retbase();
  ::com::adv::msg::RetBase* temp = retbase_;
  retbase_ = NULL;
  return temp;
}

// optional int32 transid = 32;
inline bool LogoutResult::has_transid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogoutResult::set_has_transid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogoutResult::clear_has_transid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogoutResult::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 LogoutResult::transid() const {
  return transid_;
}
inline void LogoutResult::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// TaskNotify

// required int32 tasktype = 1;
inline bool TaskNotify::has_tasktype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskNotify::set_has_tasktype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskNotify::clear_has_tasktype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskNotify::clear_tasktype() {
  tasktype_ = 0;
  clear_has_tasktype();
}
inline ::google::protobuf::int32 TaskNotify::tasktype() const {
  return tasktype_;
}
inline void TaskNotify::set_tasktype(::google::protobuf::int32 value) {
  set_has_tasktype();
  tasktype_ = value;
}

// optional int32 transid = 32;
inline bool TaskNotify::has_transid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskNotify::set_has_transid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskNotify::clear_has_transid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskNotify::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 TaskNotify::transid() const {
  return transid_;
}
inline void TaskNotify::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// SyncTaskRequest

// required int64 syncpoint = 1;
inline bool SyncTaskRequest::has_syncpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncTaskRequest::set_has_syncpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncTaskRequest::clear_has_syncpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncTaskRequest::clear_syncpoint() {
  syncpoint_ = GOOGLE_LONGLONG(0);
  clear_has_syncpoint();
}
inline ::google::protobuf::int64 SyncTaskRequest::syncpoint() const {
  return syncpoint_;
}
inline void SyncTaskRequest::set_syncpoint(::google::protobuf::int64 value) {
  set_has_syncpoint();
  syncpoint_ = value;
}

// required int32 synctype = 2;
inline bool SyncTaskRequest::has_synctype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncTaskRequest::set_has_synctype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncTaskRequest::clear_has_synctype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncTaskRequest::clear_synctype() {
  synctype_ = 0;
  clear_has_synctype();
}
inline ::google::protobuf::int32 SyncTaskRequest::synctype() const {
  return synctype_;
}
inline void SyncTaskRequest::set_synctype(::google::protobuf::int32 value) {
  set_has_synctype();
  synctype_ = value;
}

// optional int32 syncflag = 3;
inline bool SyncTaskRequest::has_syncflag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncTaskRequest::set_has_syncflag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncTaskRequest::clear_has_syncflag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncTaskRequest::clear_syncflag() {
  syncflag_ = 0;
  clear_has_syncflag();
}
inline ::google::protobuf::int32 SyncTaskRequest::syncflag() const {
  return syncflag_;
}
inline void SyncTaskRequest::set_syncflag(::google::protobuf::int32 value) {
  set_has_syncflag();
  syncflag_ = value;
}

// optional int32 synclimit = 4;
inline bool SyncTaskRequest::has_synclimit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SyncTaskRequest::set_has_synclimit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SyncTaskRequest::clear_has_synclimit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SyncTaskRequest::clear_synclimit() {
  synclimit_ = 0;
  clear_has_synclimit();
}
inline ::google::protobuf::int32 SyncTaskRequest::synclimit() const {
  return synclimit_;
}
inline void SyncTaskRequest::set_synclimit(::google::protobuf::int32 value) {
  set_has_synclimit();
  synclimit_ = value;
}

// optional int32 transid = 32;
inline bool SyncTaskRequest::has_transid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SyncTaskRequest::set_has_transid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SyncTaskRequest::clear_has_transid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SyncTaskRequest::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 SyncTaskRequest::transid() const {
  return transid_;
}
inline void SyncTaskRequest::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// SyncTaskResult

// required .com.adv.msg.RetBase retbase = 1;
inline bool SyncTaskResult::has_retbase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncTaskResult::set_has_retbase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncTaskResult::clear_has_retbase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncTaskResult::clear_retbase() {
  if (retbase_ != NULL) retbase_->::com::adv::msg::RetBase::Clear();
  clear_has_retbase();
}
inline const ::com::adv::msg::RetBase& SyncTaskResult::retbase() const {
  return retbase_ != NULL ? *retbase_ : *default_instance_->retbase_;
}
inline ::com::adv::msg::RetBase* SyncTaskResult::mutable_retbase() {
  set_has_retbase();
  if (retbase_ == NULL) retbase_ = new ::com::adv::msg::RetBase;
  return retbase_;
}
inline ::com::adv::msg::RetBase* SyncTaskResult::release_retbase() {
  clear_has_retbase();
  ::com::adv::msg::RetBase* temp = retbase_;
  retbase_ = NULL;
  return temp;
}

// repeated .com.adv.msg.TaskInfo taskinfos = 2;
inline int SyncTaskResult::taskinfos_size() const {
  return taskinfos_.size();
}
inline void SyncTaskResult::clear_taskinfos() {
  taskinfos_.Clear();
}
inline const ::com::adv::msg::TaskInfo& SyncTaskResult::taskinfos(int index) const {
  return taskinfos_.Get(index);
}
inline ::com::adv::msg::TaskInfo* SyncTaskResult::mutable_taskinfos(int index) {
  return taskinfos_.Mutable(index);
}
inline ::com::adv::msg::TaskInfo* SyncTaskResult::add_taskinfos() {
  return taskinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::adv::msg::TaskInfo >&
SyncTaskResult::taskinfos() const {
  return taskinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::adv::msg::TaskInfo >*
SyncTaskResult::mutable_taskinfos() {
  return &taskinfos_;
}

// required int32 synctype = 3;
inline bool SyncTaskResult::has_synctype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncTaskResult::set_has_synctype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncTaskResult::clear_has_synctype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncTaskResult::clear_synctype() {
  synctype_ = 0;
  clear_has_synctype();
}
inline ::google::protobuf::int32 SyncTaskResult::synctype() const {
  return synctype_;
}
inline void SyncTaskResult::set_synctype(::google::protobuf::int32 value) {
  set_has_synctype();
  synctype_ = value;
}

// optional int32 continueflag = 4;
inline bool SyncTaskResult::has_continueflag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SyncTaskResult::set_has_continueflag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SyncTaskResult::clear_has_continueflag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SyncTaskResult::clear_continueflag() {
  continueflag_ = 0;
  clear_has_continueflag();
}
inline ::google::protobuf::int32 SyncTaskResult::continueflag() const {
  return continueflag_;
}
inline void SyncTaskResult::set_continueflag(::google::protobuf::int32 value) {
  set_has_continueflag();
  continueflag_ = value;
}

// optional int64 maxtaskid = 5;
inline bool SyncTaskResult::has_maxtaskid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SyncTaskResult::set_has_maxtaskid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SyncTaskResult::clear_has_maxtaskid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SyncTaskResult::clear_maxtaskid() {
  maxtaskid_ = GOOGLE_LONGLONG(0);
  clear_has_maxtaskid();
}
inline ::google::protobuf::int64 SyncTaskResult::maxtaskid() const {
  return maxtaskid_;
}
inline void SyncTaskResult::set_maxtaskid(::google::protobuf::int64 value) {
  set_has_maxtaskid();
  maxtaskid_ = value;
}

// optional int32 transid = 32;
inline bool SyncTaskResult::has_transid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SyncTaskResult::set_has_transid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SyncTaskResult::clear_has_transid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SyncTaskResult::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 SyncTaskResult::transid() const {
  return transid_;
}
inline void SyncTaskResult::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// ReportTaskRequest

// required .com.adv.msg.TaskInfo taskinfo = 1;
inline bool ReportTaskRequest::has_taskinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportTaskRequest::set_has_taskinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReportTaskRequest::clear_has_taskinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReportTaskRequest::clear_taskinfo() {
  if (taskinfo_ != NULL) taskinfo_->::com::adv::msg::TaskInfo::Clear();
  clear_has_taskinfo();
}
inline const ::com::adv::msg::TaskInfo& ReportTaskRequest::taskinfo() const {
  return taskinfo_ != NULL ? *taskinfo_ : *default_instance_->taskinfo_;
}
inline ::com::adv::msg::TaskInfo* ReportTaskRequest::mutable_taskinfo() {
  set_has_taskinfo();
  if (taskinfo_ == NULL) taskinfo_ = new ::com::adv::msg::TaskInfo;
  return taskinfo_;
}
inline ::com::adv::msg::TaskInfo* ReportTaskRequest::release_taskinfo() {
  clear_has_taskinfo();
  ::com::adv::msg::TaskInfo* temp = taskinfo_;
  taskinfo_ = NULL;
  return temp;
}

// optional string reward = 2;
inline bool ReportTaskRequest::has_reward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReportTaskRequest::set_has_reward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReportTaskRequest::clear_has_reward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReportTaskRequest::clear_reward() {
  if (reward_ != &::google::protobuf::internal::kEmptyString) {
    reward_->clear();
  }
  clear_has_reward();
}
inline const ::std::string& ReportTaskRequest::reward() const {
  return *reward_;
}
inline void ReportTaskRequest::set_reward(const ::std::string& value) {
  set_has_reward();
  if (reward_ == &::google::protobuf::internal::kEmptyString) {
    reward_ = new ::std::string;
  }
  reward_->assign(value);
}
inline void ReportTaskRequest::set_reward(const char* value) {
  set_has_reward();
  if (reward_ == &::google::protobuf::internal::kEmptyString) {
    reward_ = new ::std::string;
  }
  reward_->assign(value);
}
inline void ReportTaskRequest::set_reward(const char* value, size_t size) {
  set_has_reward();
  if (reward_ == &::google::protobuf::internal::kEmptyString) {
    reward_ = new ::std::string;
  }
  reward_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReportTaskRequest::mutable_reward() {
  set_has_reward();
  if (reward_ == &::google::protobuf::internal::kEmptyString) {
    reward_ = new ::std::string;
  }
  return reward_;
}
inline ::std::string* ReportTaskRequest::release_reward() {
  clear_has_reward();
  if (reward_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reward_;
    reward_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 transid = 32;
inline bool ReportTaskRequest::has_transid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReportTaskRequest::set_has_transid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReportTaskRequest::clear_has_transid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReportTaskRequest::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 ReportTaskRequest::transid() const {
  return transid_;
}
inline void ReportTaskRequest::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// ReportTaskResult

// required .com.adv.msg.RetBase retbase = 1;
inline bool ReportTaskResult::has_retbase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportTaskResult::set_has_retbase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReportTaskResult::clear_has_retbase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReportTaskResult::clear_retbase() {
  if (retbase_ != NULL) retbase_->::com::adv::msg::RetBase::Clear();
  clear_has_retbase();
}
inline const ::com::adv::msg::RetBase& ReportTaskResult::retbase() const {
  return retbase_ != NULL ? *retbase_ : *default_instance_->retbase_;
}
inline ::com::adv::msg::RetBase* ReportTaskResult::mutable_retbase() {
  set_has_retbase();
  if (retbase_ == NULL) retbase_ = new ::com::adv::msg::RetBase;
  return retbase_;
}
inline ::com::adv::msg::RetBase* ReportTaskResult::release_retbase() {
  clear_has_retbase();
  ::com::adv::msg::RetBase* temp = retbase_;
  retbase_ = NULL;
  return temp;
}

// required int64 taskid = 2;
inline bool ReportTaskResult::has_taskid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReportTaskResult::set_has_taskid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReportTaskResult::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReportTaskResult::clear_taskid() {
  taskid_ = GOOGLE_LONGLONG(0);
  clear_has_taskid();
}
inline ::google::protobuf::int64 ReportTaskResult::taskid() const {
  return taskid_;
}
inline void ReportTaskResult::set_taskid(::google::protobuf::int64 value) {
  set_has_taskid();
  taskid_ = value;
}

// required string reward = 3;
inline bool ReportTaskResult::has_reward() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReportTaskResult::set_has_reward() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReportTaskResult::clear_has_reward() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReportTaskResult::clear_reward() {
  if (reward_ != &::google::protobuf::internal::kEmptyString) {
    reward_->clear();
  }
  clear_has_reward();
}
inline const ::std::string& ReportTaskResult::reward() const {
  return *reward_;
}
inline void ReportTaskResult::set_reward(const ::std::string& value) {
  set_has_reward();
  if (reward_ == &::google::protobuf::internal::kEmptyString) {
    reward_ = new ::std::string;
  }
  reward_->assign(value);
}
inline void ReportTaskResult::set_reward(const char* value) {
  set_has_reward();
  if (reward_ == &::google::protobuf::internal::kEmptyString) {
    reward_ = new ::std::string;
  }
  reward_->assign(value);
}
inline void ReportTaskResult::set_reward(const char* value, size_t size) {
  set_has_reward();
  if (reward_ == &::google::protobuf::internal::kEmptyString) {
    reward_ = new ::std::string;
  }
  reward_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReportTaskResult::mutable_reward() {
  set_has_reward();
  if (reward_ == &::google::protobuf::internal::kEmptyString) {
    reward_ = new ::std::string;
  }
  return reward_;
}
inline ::std::string* ReportTaskResult::release_reward() {
  clear_has_reward();
  if (reward_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reward_;
    reward_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 done_step = 4;
inline bool ReportTaskResult::has_done_step() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReportTaskResult::set_has_done_step() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReportTaskResult::clear_has_done_step() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReportTaskResult::clear_done_step() {
  done_step_ = 0;
  clear_has_done_step();
}
inline ::google::protobuf::int32 ReportTaskResult::done_step() const {
  return done_step_;
}
inline void ReportTaskResult::set_done_step(::google::protobuf::int32 value) {
  set_has_done_step();
  done_step_ = value;
}

// optional int32 tasktype = 5;
inline bool ReportTaskResult::has_tasktype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReportTaskResult::set_has_tasktype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReportTaskResult::clear_has_tasktype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReportTaskResult::clear_tasktype() {
  tasktype_ = 0;
  clear_has_tasktype();
}
inline ::google::protobuf::int32 ReportTaskResult::tasktype() const {
  return tasktype_;
}
inline void ReportTaskResult::set_tasktype(::google::protobuf::int32 value) {
  set_has_tasktype();
  tasktype_ = value;
}

// optional int32 report_time = 6;
inline bool ReportTaskResult::has_report_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReportTaskResult::set_has_report_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReportTaskResult::clear_has_report_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReportTaskResult::clear_report_time() {
  report_time_ = 0;
  clear_has_report_time();
}
inline ::google::protobuf::int32 ReportTaskResult::report_time() const {
  return report_time_;
}
inline void ReportTaskResult::set_report_time(::google::protobuf::int32 value) {
  set_has_report_time();
  report_time_ = value;
}

// optional int32 transid = 32;
inline bool ReportTaskResult::has_transid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReportTaskResult::set_has_transid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReportTaskResult::clear_has_transid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReportTaskResult::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 ReportTaskResult::transid() const {
  return transid_;
}
inline void ReportTaskResult::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// GetIncomeRequest

// optional int32 transid = 32;
inline bool GetIncomeRequest::has_transid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetIncomeRequest::set_has_transid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetIncomeRequest::clear_has_transid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetIncomeRequest::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 GetIncomeRequest::transid() const {
  return transid_;
}
inline void GetIncomeRequest::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// GetIncomeResult

// required .com.adv.msg.RetBase retbase = 1;
inline bool GetIncomeResult::has_retbase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetIncomeResult::set_has_retbase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetIncomeResult::clear_has_retbase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetIncomeResult::clear_retbase() {
  if (retbase_ != NULL) retbase_->::com::adv::msg::RetBase::Clear();
  clear_has_retbase();
}
inline const ::com::adv::msg::RetBase& GetIncomeResult::retbase() const {
  return retbase_ != NULL ? *retbase_ : *default_instance_->retbase_;
}
inline ::com::adv::msg::RetBase* GetIncomeResult::mutable_retbase() {
  set_has_retbase();
  if (retbase_ == NULL) retbase_ = new ::com::adv::msg::RetBase;
  return retbase_;
}
inline ::com::adv::msg::RetBase* GetIncomeResult::release_retbase() {
  clear_has_retbase();
  ::com::adv::msg::RetBase* temp = retbase_;
  retbase_ = NULL;
  return temp;
}

// required string pre_cash = 2;
inline bool GetIncomeResult::has_pre_cash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetIncomeResult::set_has_pre_cash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetIncomeResult::clear_has_pre_cash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetIncomeResult::clear_pre_cash() {
  if (pre_cash_ != &::google::protobuf::internal::kEmptyString) {
    pre_cash_->clear();
  }
  clear_has_pre_cash();
}
inline const ::std::string& GetIncomeResult::pre_cash() const {
  return *pre_cash_;
}
inline void GetIncomeResult::set_pre_cash(const ::std::string& value) {
  set_has_pre_cash();
  if (pre_cash_ == &::google::protobuf::internal::kEmptyString) {
    pre_cash_ = new ::std::string;
  }
  pre_cash_->assign(value);
}
inline void GetIncomeResult::set_pre_cash(const char* value) {
  set_has_pre_cash();
  if (pre_cash_ == &::google::protobuf::internal::kEmptyString) {
    pre_cash_ = new ::std::string;
  }
  pre_cash_->assign(value);
}
inline void GetIncomeResult::set_pre_cash(const char* value, size_t size) {
  set_has_pre_cash();
  if (pre_cash_ == &::google::protobuf::internal::kEmptyString) {
    pre_cash_ = new ::std::string;
  }
  pre_cash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetIncomeResult::mutable_pre_cash() {
  set_has_pre_cash();
  if (pre_cash_ == &::google::protobuf::internal::kEmptyString) {
    pre_cash_ = new ::std::string;
  }
  return pre_cash_;
}
inline ::std::string* GetIncomeResult::release_pre_cash() {
  clear_has_pre_cash();
  if (pre_cash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pre_cash_;
    pre_cash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string useable_cash = 3;
inline bool GetIncomeResult::has_useable_cash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetIncomeResult::set_has_useable_cash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetIncomeResult::clear_has_useable_cash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetIncomeResult::clear_useable_cash() {
  if (useable_cash_ != &::google::protobuf::internal::kEmptyString) {
    useable_cash_->clear();
  }
  clear_has_useable_cash();
}
inline const ::std::string& GetIncomeResult::useable_cash() const {
  return *useable_cash_;
}
inline void GetIncomeResult::set_useable_cash(const ::std::string& value) {
  set_has_useable_cash();
  if (useable_cash_ == &::google::protobuf::internal::kEmptyString) {
    useable_cash_ = new ::std::string;
  }
  useable_cash_->assign(value);
}
inline void GetIncomeResult::set_useable_cash(const char* value) {
  set_has_useable_cash();
  if (useable_cash_ == &::google::protobuf::internal::kEmptyString) {
    useable_cash_ = new ::std::string;
  }
  useable_cash_->assign(value);
}
inline void GetIncomeResult::set_useable_cash(const char* value, size_t size) {
  set_has_useable_cash();
  if (useable_cash_ == &::google::protobuf::internal::kEmptyString) {
    useable_cash_ = new ::std::string;
  }
  useable_cash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetIncomeResult::mutable_useable_cash() {
  set_has_useable_cash();
  if (useable_cash_ == &::google::protobuf::internal::kEmptyString) {
    useable_cash_ = new ::std::string;
  }
  return useable_cash_;
}
inline ::std::string* GetIncomeResult::release_useable_cash() {
  clear_has_useable_cash();
  if (useable_cash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = useable_cash_;
    useable_cash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string fetched_cash = 4;
inline bool GetIncomeResult::has_fetched_cash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetIncomeResult::set_has_fetched_cash() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetIncomeResult::clear_has_fetched_cash() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetIncomeResult::clear_fetched_cash() {
  if (fetched_cash_ != &::google::protobuf::internal::kEmptyString) {
    fetched_cash_->clear();
  }
  clear_has_fetched_cash();
}
inline const ::std::string& GetIncomeResult::fetched_cash() const {
  return *fetched_cash_;
}
inline void GetIncomeResult::set_fetched_cash(const ::std::string& value) {
  set_has_fetched_cash();
  if (fetched_cash_ == &::google::protobuf::internal::kEmptyString) {
    fetched_cash_ = new ::std::string;
  }
  fetched_cash_->assign(value);
}
inline void GetIncomeResult::set_fetched_cash(const char* value) {
  set_has_fetched_cash();
  if (fetched_cash_ == &::google::protobuf::internal::kEmptyString) {
    fetched_cash_ = new ::std::string;
  }
  fetched_cash_->assign(value);
}
inline void GetIncomeResult::set_fetched_cash(const char* value, size_t size) {
  set_has_fetched_cash();
  if (fetched_cash_ == &::google::protobuf::internal::kEmptyString) {
    fetched_cash_ = new ::std::string;
  }
  fetched_cash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetIncomeResult::mutable_fetched_cash() {
  set_has_fetched_cash();
  if (fetched_cash_ == &::google::protobuf::internal::kEmptyString) {
    fetched_cash_ = new ::std::string;
  }
  return fetched_cash_;
}
inline ::std::string* GetIncomeResult::release_fetched_cash() {
  clear_has_fetched_cash();
  if (fetched_cash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fetched_cash_;
    fetched_cash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 rank = 5;
inline bool GetIncomeResult::has_rank() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetIncomeResult::set_has_rank() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetIncomeResult::clear_has_rank() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetIncomeResult::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 GetIncomeResult::rank() const {
  return rank_;
}
inline void GetIncomeResult::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// optional string desc = 6;
inline bool GetIncomeResult::has_desc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetIncomeResult::set_has_desc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetIncomeResult::clear_has_desc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetIncomeResult::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& GetIncomeResult::desc() const {
  return *desc_;
}
inline void GetIncomeResult::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void GetIncomeResult::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void GetIncomeResult::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetIncomeResult::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* GetIncomeResult::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 transid = 32;
inline bool GetIncomeResult::has_transid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetIncomeResult::set_has_transid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetIncomeResult::clear_has_transid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetIncomeResult::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 GetIncomeResult::transid() const {
  return transid_;
}
inline void GetIncomeResult::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// AckRequest

// required int32 type = 1;
inline bool AckRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 AckRequest::type() const {
  return type_;
}
inline void AckRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated int64 id = 2;
inline int AckRequest::id_size() const {
  return id_.size();
}
inline void AckRequest::clear_id() {
  id_.Clear();
}
inline ::google::protobuf::int64 AckRequest::id(int index) const {
  return id_.Get(index);
}
inline void AckRequest::set_id(int index, ::google::protobuf::int64 value) {
  id_.Set(index, value);
}
inline void AckRequest::add_id(::google::protobuf::int64 value) {
  id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
AckRequest::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
AckRequest::mutable_id() {
  return &id_;
}

// optional int32 time = 3;
inline bool AckRequest::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckRequest::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckRequest::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckRequest::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 AckRequest::time() const {
  return time_;
}
inline void AckRequest::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// optional int32 transid = 32;
inline bool AckRequest::has_transid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckRequest::set_has_transid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckRequest::clear_has_transid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckRequest::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 AckRequest::transid() const {
  return transid_;
}
inline void AckRequest::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// SaveTaskRequest

// repeated .com.adv.msg.TaskInfo taskinfo = 1;
inline int SaveTaskRequest::taskinfo_size() const {
  return taskinfo_.size();
}
inline void SaveTaskRequest::clear_taskinfo() {
  taskinfo_.Clear();
}
inline const ::com::adv::msg::TaskInfo& SaveTaskRequest::taskinfo(int index) const {
  return taskinfo_.Get(index);
}
inline ::com::adv::msg::TaskInfo* SaveTaskRequest::mutable_taskinfo(int index) {
  return taskinfo_.Mutable(index);
}
inline ::com::adv::msg::TaskInfo* SaveTaskRequest::add_taskinfo() {
  return taskinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::adv::msg::TaskInfo >&
SaveTaskRequest::taskinfo() const {
  return taskinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::adv::msg::TaskInfo >*
SaveTaskRequest::mutable_taskinfo() {
  return &taskinfo_;
}

// optional int32 transid = 32;
inline bool SaveTaskRequest::has_transid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SaveTaskRequest::set_has_transid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SaveTaskRequest::clear_has_transid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SaveTaskRequest::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 SaveTaskRequest::transid() const {
  return transid_;
}
inline void SaveTaskRequest::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// SaveTaskResult

// required .com.adv.msg.RetBase retbase = 1;
inline bool SaveTaskResult::has_retbase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SaveTaskResult::set_has_retbase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SaveTaskResult::clear_has_retbase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SaveTaskResult::clear_retbase() {
  if (retbase_ != NULL) retbase_->::com::adv::msg::RetBase::Clear();
  clear_has_retbase();
}
inline const ::com::adv::msg::RetBase& SaveTaskResult::retbase() const {
  return retbase_ != NULL ? *retbase_ : *default_instance_->retbase_;
}
inline ::com::adv::msg::RetBase* SaveTaskResult::mutable_retbase() {
  set_has_retbase();
  if (retbase_ == NULL) retbase_ = new ::com::adv::msg::RetBase;
  return retbase_;
}
inline ::com::adv::msg::RetBase* SaveTaskResult::release_retbase() {
  clear_has_retbase();
  ::com::adv::msg::RetBase* temp = retbase_;
  retbase_ = NULL;
  return temp;
}

// optional int32 transid = 32;
inline bool SaveTaskResult::has_transid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SaveTaskResult::set_has_transid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SaveTaskResult::clear_has_transid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SaveTaskResult::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 SaveTaskResult::transid() const {
  return transid_;
}
inline void SaveTaskResult::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// WithdrawRequest

// required int32 type = 1;
inline bool WithdrawRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WithdrawRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WithdrawRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WithdrawRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 WithdrawRequest::type() const {
  return type_;
}
inline void WithdrawRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 withdraw_cash = 2;
inline bool WithdrawRequest::has_withdraw_cash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WithdrawRequest::set_has_withdraw_cash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WithdrawRequest::clear_has_withdraw_cash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WithdrawRequest::clear_withdraw_cash() {
  withdraw_cash_ = 0;
  clear_has_withdraw_cash();
}
inline ::google::protobuf::int32 WithdrawRequest::withdraw_cash() const {
  return withdraw_cash_;
}
inline void WithdrawRequest::set_withdraw_cash(::google::protobuf::int32 value) {
  set_has_withdraw_cash();
  withdraw_cash_ = value;
}

// required string id = 3;
inline bool WithdrawRequest::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WithdrawRequest::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WithdrawRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WithdrawRequest::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& WithdrawRequest::id() const {
  return *id_;
}
inline void WithdrawRequest::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void WithdrawRequest::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void WithdrawRequest::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WithdrawRequest::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* WithdrawRequest::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string open_id = 4;
inline bool WithdrawRequest::has_open_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WithdrawRequest::set_has_open_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WithdrawRequest::clear_has_open_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WithdrawRequest::clear_open_id() {
  if (open_id_ != &::google::protobuf::internal::kEmptyString) {
    open_id_->clear();
  }
  clear_has_open_id();
}
inline const ::std::string& WithdrawRequest::open_id() const {
  return *open_id_;
}
inline void WithdrawRequest::set_open_id(const ::std::string& value) {
  set_has_open_id();
  if (open_id_ == &::google::protobuf::internal::kEmptyString) {
    open_id_ = new ::std::string;
  }
  open_id_->assign(value);
}
inline void WithdrawRequest::set_open_id(const char* value) {
  set_has_open_id();
  if (open_id_ == &::google::protobuf::internal::kEmptyString) {
    open_id_ = new ::std::string;
  }
  open_id_->assign(value);
}
inline void WithdrawRequest::set_open_id(const char* value, size_t size) {
  set_has_open_id();
  if (open_id_ == &::google::protobuf::internal::kEmptyString) {
    open_id_ = new ::std::string;
  }
  open_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WithdrawRequest::mutable_open_id() {
  set_has_open_id();
  if (open_id_ == &::google::protobuf::internal::kEmptyString) {
    open_id_ = new ::std::string;
  }
  return open_id_;
}
inline ::std::string* WithdrawRequest::release_open_id() {
  clear_has_open_id();
  if (open_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = open_id_;
    open_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string passwd = 5;
inline bool WithdrawRequest::has_passwd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WithdrawRequest::set_has_passwd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WithdrawRequest::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WithdrawRequest::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& WithdrawRequest::passwd() const {
  return *passwd_;
}
inline void WithdrawRequest::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void WithdrawRequest::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void WithdrawRequest::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WithdrawRequest::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* WithdrawRequest::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string user_name = 6;
inline bool WithdrawRequest::has_user_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WithdrawRequest::set_has_user_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WithdrawRequest::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WithdrawRequest::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& WithdrawRequest::user_name() const {
  return *user_name_;
}
inline void WithdrawRequest::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void WithdrawRequest::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void WithdrawRequest::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WithdrawRequest::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* WithdrawRequest::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string desc = 7;
inline bool WithdrawRequest::has_desc() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WithdrawRequest::set_has_desc() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WithdrawRequest::clear_has_desc() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WithdrawRequest::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& WithdrawRequest::desc() const {
  return *desc_;
}
inline void WithdrawRequest::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void WithdrawRequest::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void WithdrawRequest::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WithdrawRequest::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* WithdrawRequest::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 time = 8;
inline bool WithdrawRequest::has_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WithdrawRequest::set_has_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void WithdrawRequest::clear_has_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void WithdrawRequest::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 WithdrawRequest::time() const {
  return time_;
}
inline void WithdrawRequest::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// optional int32 transid = 32;
inline bool WithdrawRequest::has_transid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WithdrawRequest::set_has_transid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void WithdrawRequest::clear_has_transid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void WithdrawRequest::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 WithdrawRequest::transid() const {
  return transid_;
}
inline void WithdrawRequest::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// WithdrawResult

// required .com.adv.msg.RetBase retbase = 1;
inline bool WithdrawResult::has_retbase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WithdrawResult::set_has_retbase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WithdrawResult::clear_has_retbase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WithdrawResult::clear_retbase() {
  if (retbase_ != NULL) retbase_->::com::adv::msg::RetBase::Clear();
  clear_has_retbase();
}
inline const ::com::adv::msg::RetBase& WithdrawResult::retbase() const {
  return retbase_ != NULL ? *retbase_ : *default_instance_->retbase_;
}
inline ::com::adv::msg::RetBase* WithdrawResult::mutable_retbase() {
  set_has_retbase();
  if (retbase_ == NULL) retbase_ = new ::com::adv::msg::RetBase;
  return retbase_;
}
inline ::com::adv::msg::RetBase* WithdrawResult::release_retbase() {
  clear_has_retbase();
  ::com::adv::msg::RetBase* temp = retbase_;
  retbase_ = NULL;
  return temp;
}

// required int32 type = 2;
inline bool WithdrawResult::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WithdrawResult::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WithdrawResult::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WithdrawResult::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 WithdrawResult::type() const {
  return type_;
}
inline void WithdrawResult::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 withdraw_cash = 3;
inline bool WithdrawResult::has_withdraw_cash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WithdrawResult::set_has_withdraw_cash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WithdrawResult::clear_has_withdraw_cash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WithdrawResult::clear_withdraw_cash() {
  withdraw_cash_ = 0;
  clear_has_withdraw_cash();
}
inline ::google::protobuf::int32 WithdrawResult::withdraw_cash() const {
  return withdraw_cash_;
}
inline void WithdrawResult::set_withdraw_cash(::google::protobuf::int32 value) {
  set_has_withdraw_cash();
  withdraw_cash_ = value;
}

// required string trade_id = 4;
inline bool WithdrawResult::has_trade_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WithdrawResult::set_has_trade_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WithdrawResult::clear_has_trade_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WithdrawResult::clear_trade_id() {
  if (trade_id_ != &::google::protobuf::internal::kEmptyString) {
    trade_id_->clear();
  }
  clear_has_trade_id();
}
inline const ::std::string& WithdrawResult::trade_id() const {
  return *trade_id_;
}
inline void WithdrawResult::set_trade_id(const ::std::string& value) {
  set_has_trade_id();
  if (trade_id_ == &::google::protobuf::internal::kEmptyString) {
    trade_id_ = new ::std::string;
  }
  trade_id_->assign(value);
}
inline void WithdrawResult::set_trade_id(const char* value) {
  set_has_trade_id();
  if (trade_id_ == &::google::protobuf::internal::kEmptyString) {
    trade_id_ = new ::std::string;
  }
  trade_id_->assign(value);
}
inline void WithdrawResult::set_trade_id(const char* value, size_t size) {
  set_has_trade_id();
  if (trade_id_ == &::google::protobuf::internal::kEmptyString) {
    trade_id_ = new ::std::string;
  }
  trade_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WithdrawResult::mutable_trade_id() {
  set_has_trade_id();
  if (trade_id_ == &::google::protobuf::internal::kEmptyString) {
    trade_id_ = new ::std::string;
  }
  return trade_id_;
}
inline ::std::string* WithdrawResult::release_trade_id() {
  clear_has_trade_id();
  if (trade_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trade_id_;
    trade_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string desc = 5;
inline bool WithdrawResult::has_desc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WithdrawResult::set_has_desc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WithdrawResult::clear_has_desc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WithdrawResult::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& WithdrawResult::desc() const {
  return *desc_;
}
inline void WithdrawResult::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void WithdrawResult::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void WithdrawResult::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WithdrawResult::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* WithdrawResult::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 time = 6;
inline bool WithdrawResult::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WithdrawResult::set_has_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WithdrawResult::clear_has_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WithdrawResult::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 WithdrawResult::time() const {
  return time_;
}
inline void WithdrawResult::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// optional string pre_cash = 7;
inline bool WithdrawResult::has_pre_cash() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WithdrawResult::set_has_pre_cash() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WithdrawResult::clear_has_pre_cash() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WithdrawResult::clear_pre_cash() {
  if (pre_cash_ != &::google::protobuf::internal::kEmptyString) {
    pre_cash_->clear();
  }
  clear_has_pre_cash();
}
inline const ::std::string& WithdrawResult::pre_cash() const {
  return *pre_cash_;
}
inline void WithdrawResult::set_pre_cash(const ::std::string& value) {
  set_has_pre_cash();
  if (pre_cash_ == &::google::protobuf::internal::kEmptyString) {
    pre_cash_ = new ::std::string;
  }
  pre_cash_->assign(value);
}
inline void WithdrawResult::set_pre_cash(const char* value) {
  set_has_pre_cash();
  if (pre_cash_ == &::google::protobuf::internal::kEmptyString) {
    pre_cash_ = new ::std::string;
  }
  pre_cash_->assign(value);
}
inline void WithdrawResult::set_pre_cash(const char* value, size_t size) {
  set_has_pre_cash();
  if (pre_cash_ == &::google::protobuf::internal::kEmptyString) {
    pre_cash_ = new ::std::string;
  }
  pre_cash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WithdrawResult::mutable_pre_cash() {
  set_has_pre_cash();
  if (pre_cash_ == &::google::protobuf::internal::kEmptyString) {
    pre_cash_ = new ::std::string;
  }
  return pre_cash_;
}
inline ::std::string* WithdrawResult::release_pre_cash() {
  clear_has_pre_cash();
  if (pre_cash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pre_cash_;
    pre_cash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string useable_cash = 8;
inline bool WithdrawResult::has_useable_cash() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WithdrawResult::set_has_useable_cash() {
  _has_bits_[0] |= 0x00000080u;
}
inline void WithdrawResult::clear_has_useable_cash() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void WithdrawResult::clear_useable_cash() {
  if (useable_cash_ != &::google::protobuf::internal::kEmptyString) {
    useable_cash_->clear();
  }
  clear_has_useable_cash();
}
inline const ::std::string& WithdrawResult::useable_cash() const {
  return *useable_cash_;
}
inline void WithdrawResult::set_useable_cash(const ::std::string& value) {
  set_has_useable_cash();
  if (useable_cash_ == &::google::protobuf::internal::kEmptyString) {
    useable_cash_ = new ::std::string;
  }
  useable_cash_->assign(value);
}
inline void WithdrawResult::set_useable_cash(const char* value) {
  set_has_useable_cash();
  if (useable_cash_ == &::google::protobuf::internal::kEmptyString) {
    useable_cash_ = new ::std::string;
  }
  useable_cash_->assign(value);
}
inline void WithdrawResult::set_useable_cash(const char* value, size_t size) {
  set_has_useable_cash();
  if (useable_cash_ == &::google::protobuf::internal::kEmptyString) {
    useable_cash_ = new ::std::string;
  }
  useable_cash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WithdrawResult::mutable_useable_cash() {
  set_has_useable_cash();
  if (useable_cash_ == &::google::protobuf::internal::kEmptyString) {
    useable_cash_ = new ::std::string;
  }
  return useable_cash_;
}
inline ::std::string* WithdrawResult::release_useable_cash() {
  clear_has_useable_cash();
  if (useable_cash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = useable_cash_;
    useable_cash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string fetched_cash = 9;
inline bool WithdrawResult::has_fetched_cash() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WithdrawResult::set_has_fetched_cash() {
  _has_bits_[0] |= 0x00000100u;
}
inline void WithdrawResult::clear_has_fetched_cash() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void WithdrawResult::clear_fetched_cash() {
  if (fetched_cash_ != &::google::protobuf::internal::kEmptyString) {
    fetched_cash_->clear();
  }
  clear_has_fetched_cash();
}
inline const ::std::string& WithdrawResult::fetched_cash() const {
  return *fetched_cash_;
}
inline void WithdrawResult::set_fetched_cash(const ::std::string& value) {
  set_has_fetched_cash();
  if (fetched_cash_ == &::google::protobuf::internal::kEmptyString) {
    fetched_cash_ = new ::std::string;
  }
  fetched_cash_->assign(value);
}
inline void WithdrawResult::set_fetched_cash(const char* value) {
  set_has_fetched_cash();
  if (fetched_cash_ == &::google::protobuf::internal::kEmptyString) {
    fetched_cash_ = new ::std::string;
  }
  fetched_cash_->assign(value);
}
inline void WithdrawResult::set_fetched_cash(const char* value, size_t size) {
  set_has_fetched_cash();
  if (fetched_cash_ == &::google::protobuf::internal::kEmptyString) {
    fetched_cash_ = new ::std::string;
  }
  fetched_cash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WithdrawResult::mutable_fetched_cash() {
  set_has_fetched_cash();
  if (fetched_cash_ == &::google::protobuf::internal::kEmptyString) {
    fetched_cash_ = new ::std::string;
  }
  return fetched_cash_;
}
inline ::std::string* WithdrawResult::release_fetched_cash() {
  clear_has_fetched_cash();
  if (fetched_cash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fetched_cash_;
    fetched_cash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 transid = 32;
inline bool WithdrawResult::has_transid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void WithdrawResult::set_has_transid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void WithdrawResult::clear_has_transid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void WithdrawResult::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 WithdrawResult::transid() const {
  return transid_;
}
inline void WithdrawResult::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// MysqlRequest

// required int32 sqlid = 1;
inline bool MysqlRequest::has_sqlid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MysqlRequest::set_has_sqlid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MysqlRequest::clear_has_sqlid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MysqlRequest::clear_sqlid() {
  sqlid_ = 0;
  clear_has_sqlid();
}
inline ::google::protobuf::int32 MysqlRequest::sqlid() const {
  return sqlid_;
}
inline void MysqlRequest::set_sqlid(::google::protobuf::int32 value) {
  set_has_sqlid();
  sqlid_ = value;
}

// required string sql = 2;
inline bool MysqlRequest::has_sql() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MysqlRequest::set_has_sql() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MysqlRequest::clear_has_sql() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MysqlRequest::clear_sql() {
  if (sql_ != &::google::protobuf::internal::kEmptyString) {
    sql_->clear();
  }
  clear_has_sql();
}
inline const ::std::string& MysqlRequest::sql() const {
  return *sql_;
}
inline void MysqlRequest::set_sql(const ::std::string& value) {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  sql_->assign(value);
}
inline void MysqlRequest::set_sql(const char* value) {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  sql_->assign(value);
}
inline void MysqlRequest::set_sql(const char* value, size_t size) {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  sql_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MysqlRequest::mutable_sql() {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  return sql_;
}
inline ::std::string* MysqlRequest::release_sql() {
  clear_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sql_;
    sql_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 isrequestfield = 3;
inline bool MysqlRequest::has_isrequestfield() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MysqlRequest::set_has_isrequestfield() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MysqlRequest::clear_has_isrequestfield() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MysqlRequest::clear_isrequestfield() {
  isrequestfield_ = 0;
  clear_has_isrequestfield();
}
inline ::google::protobuf::int32 MysqlRequest::isrequestfield() const {
  return isrequestfield_;
}
inline void MysqlRequest::set_isrequestfield(::google::protobuf::int32 value) {
  set_has_isrequestfield();
  isrequestfield_ = value;
}

// optional int32 limit = 4;
inline bool MysqlRequest::has_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MysqlRequest::set_has_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MysqlRequest::clear_has_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MysqlRequest::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 MysqlRequest::limit() const {
  return limit_;
}
inline void MysqlRequest::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// optional int32 timeout = 5;
inline bool MysqlRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MysqlRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MysqlRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MysqlRequest::clear_timeout() {
  timeout_ = 0;
  clear_has_timeout();
}
inline ::google::protobuf::int32 MysqlRequest::timeout() const {
  return timeout_;
}
inline void MysqlRequest::set_timeout(::google::protobuf::int32 value) {
  set_has_timeout();
  timeout_ = value;
}

// -------------------------------------------------------------------

// MysqlResult

// required .com.adv.msg.RetBase retbase = 1;
inline bool MysqlResult::has_retbase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MysqlResult::set_has_retbase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MysqlResult::clear_has_retbase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MysqlResult::clear_retbase() {
  if (retbase_ != NULL) retbase_->::com::adv::msg::RetBase::Clear();
  clear_has_retbase();
}
inline const ::com::adv::msg::RetBase& MysqlResult::retbase() const {
  return retbase_ != NULL ? *retbase_ : *default_instance_->retbase_;
}
inline ::com::adv::msg::RetBase* MysqlResult::mutable_retbase() {
  set_has_retbase();
  if (retbase_ == NULL) retbase_ = new ::com::adv::msg::RetBase;
  return retbase_;
}
inline ::com::adv::msg::RetBase* MysqlResult::release_retbase() {
  clear_has_retbase();
  ::com::adv::msg::RetBase* temp = retbase_;
  retbase_ = NULL;
  return temp;
}

// optional int32 affectedrows = 2;
inline bool MysqlResult::has_affectedrows() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MysqlResult::set_has_affectedrows() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MysqlResult::clear_has_affectedrows() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MysqlResult::clear_affectedrows() {
  affectedrows_ = 0;
  clear_has_affectedrows();
}
inline ::google::protobuf::int32 MysqlResult::affectedrows() const {
  return affectedrows_;
}
inline void MysqlResult::set_affectedrows(::google::protobuf::int32 value) {
  set_has_affectedrows();
  affectedrows_ = value;
}

// optional int32 insertid = 3;
inline bool MysqlResult::has_insertid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MysqlResult::set_has_insertid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MysqlResult::clear_has_insertid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MysqlResult::clear_insertid() {
  insertid_ = 0;
  clear_has_insertid();
}
inline ::google::protobuf::int32 MysqlResult::insertid() const {
  return insertid_;
}
inline void MysqlResult::set_insertid(::google::protobuf::int32 value) {
  set_has_insertid();
  insertid_ = value;
}

// repeated .com.adv.msg.PRow rows = 4;
inline int MysqlResult::rows_size() const {
  return rows_.size();
}
inline void MysqlResult::clear_rows() {
  rows_.Clear();
}
inline const ::com::adv::msg::PRow& MysqlResult::rows(int index) const {
  return rows_.Get(index);
}
inline ::com::adv::msg::PRow* MysqlResult::mutable_rows(int index) {
  return rows_.Mutable(index);
}
inline ::com::adv::msg::PRow* MysqlResult::add_rows() {
  return rows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PRow >&
MysqlResult::rows() const {
  return rows_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PRow >*
MysqlResult::mutable_rows() {
  return &rows_;
}

// optional int32 sqlid = 5;
inline bool MysqlResult::has_sqlid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MysqlResult::set_has_sqlid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MysqlResult::clear_has_sqlid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MysqlResult::clear_sqlid() {
  sqlid_ = 0;
  clear_has_sqlid();
}
inline ::google::protobuf::int32 MysqlResult::sqlid() const {
  return sqlid_;
}
inline void MysqlResult::set_sqlid(::google::protobuf::int32 value) {
  set_has_sqlid();
  sqlid_ = value;
}

// -------------------------------------------------------------------

// RedispRequest

// required int32 sqlid = 1;
inline bool RedispRequest::has_sqlid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedispRequest::set_has_sqlid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedispRequest::clear_has_sqlid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedispRequest::clear_sqlid() {
  sqlid_ = 0;
  clear_has_sqlid();
}
inline ::google::protobuf::int32 RedispRequest::sqlid() const {
  return sqlid_;
}
inline void RedispRequest::set_sqlid(::google::protobuf::int32 value) {
  set_has_sqlid();
  sqlid_ = value;
}

// required string key = 2;
inline bool RedispRequest::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedispRequest::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedispRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedispRequest::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RedispRequest::key() const {
  return *key_;
}
inline void RedispRequest::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RedispRequest::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RedispRequest::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RedispRequest::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RedispRequest::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 param = 3;
inline bool RedispRequest::has_param() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RedispRequest::set_has_param() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RedispRequest::clear_has_param() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RedispRequest::clear_param() {
  param_ = 0;
  clear_has_param();
}
inline ::google::protobuf::int32 RedispRequest::param() const {
  return param_;
}
inline void RedispRequest::set_param(::google::protobuf::int32 value) {
  set_has_param();
  param_ = value;
}

// optional int32 limit = 4;
inline bool RedispRequest::has_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RedispRequest::set_has_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RedispRequest::clear_has_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RedispRequest::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 RedispRequest::limit() const {
  return limit_;
}
inline void RedispRequest::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// optional int32 timeout = 5;
inline bool RedispRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RedispRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RedispRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RedispRequest::clear_timeout() {
  timeout_ = 0;
  clear_has_timeout();
}
inline ::google::protobuf::int32 RedispRequest::timeout() const {
  return timeout_;
}
inline void RedispRequest::set_timeout(::google::protobuf::int32 value) {
  set_has_timeout();
  timeout_ = value;
}

// optional int32 transid = 32;
inline bool RedispRequest::has_transid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RedispRequest::set_has_transid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RedispRequest::clear_has_transid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RedispRequest::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 RedispRequest::transid() const {
  return transid_;
}
inline void RedispRequest::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// RedispResult

// required .com.adv.msg.RetBase retbase = 1;
inline bool RedispResult::has_retbase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedispResult::set_has_retbase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedispResult::clear_has_retbase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedispResult::clear_retbase() {
  if (retbase_ != NULL) retbase_->::com::adv::msg::RetBase::Clear();
  clear_has_retbase();
}
inline const ::com::adv::msg::RetBase& RedispResult::retbase() const {
  return retbase_ != NULL ? *retbase_ : *default_instance_->retbase_;
}
inline ::com::adv::msg::RetBase* RedispResult::mutable_retbase() {
  set_has_retbase();
  if (retbase_ == NULL) retbase_ = new ::com::adv::msg::RetBase;
  return retbase_;
}
inline ::com::adv::msg::RetBase* RedispResult::release_retbase() {
  clear_has_retbase();
  ::com::adv::msg::RetBase* temp = retbase_;
  retbase_ = NULL;
  return temp;
}

// optional int32 affectedrows = 2;
inline bool RedispResult::has_affectedrows() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedispResult::set_has_affectedrows() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedispResult::clear_has_affectedrows() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedispResult::clear_affectedrows() {
  affectedrows_ = 0;
  clear_has_affectedrows();
}
inline ::google::protobuf::int32 RedispResult::affectedrows() const {
  return affectedrows_;
}
inline void RedispResult::set_affectedrows(::google::protobuf::int32 value) {
  set_has_affectedrows();
  affectedrows_ = value;
}

// optional int32 insertid = 3;
inline bool RedispResult::has_insertid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RedispResult::set_has_insertid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RedispResult::clear_has_insertid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RedispResult::clear_insertid() {
  insertid_ = 0;
  clear_has_insertid();
}
inline ::google::protobuf::int32 RedispResult::insertid() const {
  return insertid_;
}
inline void RedispResult::set_insertid(::google::protobuf::int32 value) {
  set_has_insertid();
  insertid_ = value;
}

// repeated .com.adv.msg.PRow rows = 4;
inline int RedispResult::rows_size() const {
  return rows_.size();
}
inline void RedispResult::clear_rows() {
  rows_.Clear();
}
inline const ::com::adv::msg::PRow& RedispResult::rows(int index) const {
  return rows_.Get(index);
}
inline ::com::adv::msg::PRow* RedispResult::mutable_rows(int index) {
  return rows_.Mutable(index);
}
inline ::com::adv::msg::PRow* RedispResult::add_rows() {
  return rows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PRow >&
RedispResult::rows() const {
  return rows_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PRow >*
RedispResult::mutable_rows() {
  return &rows_;
}

// optional int32 sqlid = 5;
inline bool RedispResult::has_sqlid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RedispResult::set_has_sqlid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RedispResult::clear_has_sqlid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RedispResult::clear_sqlid() {
  sqlid_ = 0;
  clear_has_sqlid();
}
inline ::google::protobuf::int32 RedispResult::sqlid() const {
  return sqlid_;
}
inline void RedispResult::set_sqlid(::google::protobuf::int32 value) {
  set_has_sqlid();
  sqlid_ = value;
}

// optional int32 transid = 32;
inline bool RedispResult::has_transid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RedispResult::set_has_transid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RedispResult::clear_has_transid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RedispResult::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 RedispResult::transid() const {
  return transid_;
}
inline void RedispResult::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}

// -------------------------------------------------------------------

// InnerCommonMsg

// repeated .com.adv.msg.PDataCell items = 1;
inline int InnerCommonMsg::items_size() const {
  return items_.size();
}
inline void InnerCommonMsg::clear_items() {
  items_.Clear();
}
inline const ::com::adv::msg::PDataCell& InnerCommonMsg::items(int index) const {
  return items_.Get(index);
}
inline ::com::adv::msg::PDataCell* InnerCommonMsg::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::com::adv::msg::PDataCell* InnerCommonMsg::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PDataCell >&
InnerCommonMsg::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::adv::msg::PDataCell >*
InnerCommonMsg::mutable_items() {
  return &items_;
}

// optional string transfer = 2;
inline bool InnerCommonMsg::has_transfer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InnerCommonMsg::set_has_transfer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InnerCommonMsg::clear_has_transfer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InnerCommonMsg::clear_transfer() {
  if (transfer_ != &::google::protobuf::internal::kEmptyString) {
    transfer_->clear();
  }
  clear_has_transfer();
}
inline const ::std::string& InnerCommonMsg::transfer() const {
  return *transfer_;
}
inline void InnerCommonMsg::set_transfer(const ::std::string& value) {
  set_has_transfer();
  if (transfer_ == &::google::protobuf::internal::kEmptyString) {
    transfer_ = new ::std::string;
  }
  transfer_->assign(value);
}
inline void InnerCommonMsg::set_transfer(const char* value) {
  set_has_transfer();
  if (transfer_ == &::google::protobuf::internal::kEmptyString) {
    transfer_ = new ::std::string;
  }
  transfer_->assign(value);
}
inline void InnerCommonMsg::set_transfer(const char* value, size_t size) {
  set_has_transfer();
  if (transfer_ == &::google::protobuf::internal::kEmptyString) {
    transfer_ = new ::std::string;
  }
  transfer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InnerCommonMsg::mutable_transfer() {
  set_has_transfer();
  if (transfer_ == &::google::protobuf::internal::kEmptyString) {
    transfer_ = new ::std::string;
  }
  return transfer_;
}
inline ::std::string* InnerCommonMsg::release_transfer() {
  clear_has_transfer();
  if (transfer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = transfer_;
    transfer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 time = 3;
inline bool InnerCommonMsg::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InnerCommonMsg::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InnerCommonMsg::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InnerCommonMsg::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 InnerCommonMsg::time() const {
  return time_;
}
inline void InnerCommonMsg::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// optional int32 transid = 32;
inline bool InnerCommonMsg::has_transid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InnerCommonMsg::set_has_transid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InnerCommonMsg::clear_has_transid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InnerCommonMsg::clear_transid() {
  transid_ = 0;
  clear_has_transid();
}
inline ::google::protobuf::int32 InnerCommonMsg::transid() const {
  return transid_;
}
inline void InnerCommonMsg::set_transid(::google::protobuf::int32 value) {
  set_has_transid();
  transid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg
}  // namespace adv
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_adv_5fprotocol_2eproto__INCLUDED
